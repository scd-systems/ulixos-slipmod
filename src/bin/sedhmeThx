#line 1687 "../diss-hgesser-ulix.tex"
#include "ulix.h"

/* 
#line 1407 "../diss-hgesser-ulix.tex"
(c) 2008-2013 Felix Freiling, University of Erlangen-Nürnberg, Germany
(c) 2011-2013 Hans-Georg Eßer, University of Erlangen-Nürnberg, Germany
#line 1689 "../diss-hgesser-ulix.tex"
                        */
#line 1638 "../diss-hgesser-ulix.tex"
#define UNAME "Ulix-i386 0.08_h"
#define BUILDDATE "Fr 27. Dez 13:18:14 CET 2013"
#line 1707 "../diss-hgesser-ulix.tex"
#define asm __asm__
#line 1819 "../diss-hgesser-ulix.tex"
#define assert(e)  \
    ((void) ((e) ? 0 : __assert (#e, __FILE__, __LINE__), abort() ))
#define __assert(e, file, line) \
    ((void)printf ("%s:%u: failed assertion `%s'\n", file, line, e))
void abort() {
  asm ("cli; hlt");
  // for (;;); 
  // asm ("jmp simple_shell");
};
#line 17974 "../diss-hgesser-ulix.tex"
typedef void (*sighandler_t)(int);
#line 1643 "../diss-hgesser-ulix.tex"
/*
v0.01  2011/06     first version, boots, enables interrupts, keyboard handler,
                   protected mode, most code taken from kernel tutorials
v0.02  2011/07/31  paging for the kernel (not yet for user space)
v0.03  2011/08/12  paging with Higher Half Kernel / GDT trick (preparation for
                   user space)
v0.04  2011/08/17  dynamic memory allocation: request frame, request new page
                   (with update of page table; creations of new page table if
                   last used one is full) 
v0.05  2012/10/02  serial hard disk and external storage server (for use with
                   qemu & co.)
v0.07  2013/04/05  Scheduling and fork / exec / exit / waitpid are working.
v0.08  2013/07/13  Minix Filesystem support (replaces "simplefs"). Can read,
                   write, create files. No sub-directories. 
                   Kernel uses floppy (FDC controller) instead of serial disk
                   Terminal support (up to ten terminals with shells)
*/
#line 1869 "../diss-hgesser-ulix.tex"
extern void initialize_module ();
#line 1979 "../diss-hgesser-ulix.tex"
/* Defines an IDT entry */
struct idt_entry
{
    unsigned short base_lo;
    unsigned short sel;
    unsigned char always0;
    unsigned char flags;
    unsigned short base_hi;
} __attribute__((packed));

struct idt_ptr
{
    unsigned short limit;
    uint base;
} __attribute__((packed));
#line 2005 "../diss-hgesser-ulix.tex"
struct idt_entry idt[256];
struct idt_ptr idtp;

/* This exists in 'start.asm', and is used to load our IDT */
extern void idt_load();
#line 2489 "../diss-hgesser-ulix.tex"
#define boolean unsigned int
#line 2721 "../diss-hgesser-ulix.tex"
/* This will keep track of how many ticks that the system
*  has been running for */
uint system_ticks = 0;
int system_time;      // from 0 to 24*60-1
#line 2732 "../diss-hgesser-ulix.tex"
#define SCHED_SRC_TIMER   0
#define SCHED_SRC_YIELD   1
#define SCHED_SRC_WAITFOR 2
#line 2916 "../diss-hgesser-ulix.tex"
#define MAX_SYSCALLS 0x8000         // max syscall number: 0x7fff
void *syscall_table[MAX_SYSCALLS];
#line 3073 "../diss-hgesser-ulix.tex"
#define __NR_yield               66   // not from Linux
#define __NR_exit                 1
#define __NR_fork                 2
#define __NR_read                 3
#define __NR_write                4
#define __NR_open                 5
#define __NR_close                6
#define __NR_waitpid              7
#define __NR_creat                8
#define __NR_link                 9
#define __NR_unlink              10
#define __NR_execve              11
#define __NR_chdir               12
#define __NR_time                13
#define __NR_mknod               14
#define __NR_chmod               15
#define __NR_lchown              16
#define __NR_break               17
#define __NR_oldstat             18
#define __NR_lseek               19
#define __NR_getpid              20
#define __NR_mount               21
#define __NR_umount              22
#define __NR_setuid              23
#define __NR_getuid              24
#define __NR_stime               25
#define __NR_ptrace              26
#define __NR_alarm               27
#define __NR_oldfstat            28
#define __NR_pause               29
#define __NR_utime               30
#define __NR_stty                31
#define __NR_gtty                32
#define __NR_access              33
#define __NR_nice                34
#define __NR_ftime               35
#define __NR_sync                36
#define __NR_kill                37
#define __NR_rename              38
#define __NR_mkdir               39
#define __NR_rmdir               40
#define __NR_dup                 41
#define __NR_pipe                42
#define __NR_times               43
#define __NR_prof                44
#define __NR_brk                 45
#define __NR_setgid              46
#define __NR_getgid              47
#define __NR_signal              48
#define __NR_geteuid             49
#define __NR_getegid             50
#define __NR_acct                51
#define __NR_umount2             52
#define __NR_lock                53
#define __NR_ioctl               54
#define __NR_fcntl               55
#define __NR_mpx                 56
#define __NR_setpgid             57
#define __NR_ulimit              58
#define __NR_oldolduname         59
#define __NR_umask               60
#define __NR_chroot              61
#define __NR_ustat               62
#define __NR_dup2                63
#define __NR_getppid             64
#define __NR_getpgrp             65
#define __NR_setsid              66
#define __NR_sigaction           67
#define __NR_sgetmask            68
#define __NR_ssetmask            69
#define __NR_setreuid            70
#define __NR_setregid            71
#define __NR_sigsuspend          72
#define __NR_sigpending          73
#define __NR_sethostname         74
#define __NR_setrlimit           75
#define __NR_getrlimit           76   /* Back compatible 2Gig limited rlimit */
#define __NR_getrusage           77
#define __NR_gettimeofday        78
#define __NR_settimeofday        79
#define __NR_getgroups           80
#define __NR_setgroups           81
#define __NR_select              82
#define __NR_symlink             83
#define __NR_oldlstat            84
#define __NR_readlink            85
#define __NR_uselib              86
#define __NR_swapon              87
#define __NR_reboot              88
#define __NR_readdir             89
#define __NR_mmap                90
#define __NR_munmap              91
#define __NR_truncate            92
#define __NR_ftruncate           93
#define __NR_fchmod              94
#define __NR_fchown              95
#define __NR_getpriority         96
#define __NR_setpriority         97
#define __NR_profil              98
#define __NR_statfs              99
#define __NR_fstatfs            100
#define __NR_ioperm             101
#define __NR_socketcall         102
#define __NR_syslog             103
#define __NR_setitimer          104
#define __NR_getitimer          105
#define __NR_stat               106
#define __NR_lstat              107
#define __NR_fstat              108
#define __NR_olduname           109
#define __NR_iopl               110
#define __NR_vhangup            111
#define __NR_idle               112
#define __NR_vm86old            113
#define __NR_wait4              114
#define __NR_swapoff            115
#define __NR_sysinfo            116
#define __NR_ipc                117
#define __NR_fsync              118
#define __NR_sigreturn          119
#define __NR_clone              120
#define __NR_setdomainname      121
#define __NR_uname              122
#define __NR_modify_ldt         123
#define __NR_adjtimex           124
#define __NR_mprotect           125
#define __NR_sigprocmask        126
#define __NR_create_module      127
#define __NR_init_module        128
#define __NR_delete_module      129
#define __NR_get_kernel_syms    130
#define __NR_quotactl           131
#define __NR_getpgid            132
#define __NR_fchdir             133
#define __NR_bdflush            134
#define __NR_sysfs              135
#define __NR_personality        136
#define __NR_setfsuid           138
#define __NR_setfsgid           139
#define __NR__llseek            140
#define __NR_getdents           141
#define __NR__newselect         142
#define __NR_flock              143
#define __NR_msync              144
#define __NR_readv              145
#define __NR_writev             146
#define __NR_getsid             147
#define __NR_fdatasync          148
#define __NR__sysctl            149
#define __NR_mlock              150
#define __NR_munlock            151
#define __NR_mlockall           152
#define __NR_munlockall         153
#define __NR_nanosleep          162
#define __NR_mremap             163
#define __NR_setresuid          164
#define __NR_getresuid          165
#define __NR_vm86               166
#define __NR_query_module       167
#define __NR_poll               168
#define __NR_nfsservctl         169
#define __NR_setresgid          170
#define __NR_getresgid          171
#define __NR_prctl              172
#define __NR_pread64            180
#define __NR_pwrite64           181
#define __NR_chown              182
#define __NR_getcwd             183
#define __NR_capget             184
#define __NR_capset             185
#define __NR_sigaltstack        186
#define __NR_sendfile           187
#define __NR_getpmsg            188     /* some people actually want streams */
#define __NR_putpmsg            189     /* some people actually want streams */
#define __NR_vfork              190
#define __NR_ugetrlimit         191     /* SuS compliant getrlimit */
#define __NR_mmap2              192
#define __NR_truncate64         193
#define __NR_ftruncate64        194
#define __NR_stat64             195
#define __NR_lstat64            196
#define __NR_fstat64            197
#define __NR_lchown32           198
#define __NR_getuid32           199
#define __NR_getgid32           200
#define __NR_geteuid32          201
#define __NR_getegid32          202
#define __NR_setreuid32         203
#define __NR_setregid32         204
#define __NR_getgroups32        205
#define __NR_setgroups32        206
#define __NR_fchown32           207
#define __NR_setresuid32        208
#define __NR_getresuid32        209
#define __NR_setresgid32        210
#define __NR_getresgid32        211
#define __NR_chown32            212
#define __NR_setuid32           213
#define __NR_setgid32           214
#define __NR_setfsuid32         215
#define __NR_setfsgid32         216
#define __NR_pivot_root         217
#define __NR_mincore            218
#define __NR_madvise            219
#define __NR_madvise1           219     /* delete when C lib stub is removed */
#define __NR_getdents64         220
#define __NR_fcntl64            221
/* 223 is unused */
#define __NR_gettid             224
#define __NR_readahead          225
#define __NR_tkill              238
#define __NR_sendfile64         239
#define __NR_futex              240
#define __NR_sched_setaffinity  241
#define __NR_sched_getaffinity  242
#define __NR_set_thread_area    243
#define __NR_get_thread_area    244
#define __NR_io_setup           245
#define __NR_io_destroy         246
#define __NR_io_getevents       247
#define __NR_io_submit          248
#define __NR_io_cancel          249
#define __NR_fadvise64          250
/* 251 is available for reuse (was briefly sys_set_zone_reclaim) */
#define __NR_exit_group         252
#define __NR_lookup_dcookie     253
#define __NR_epoll_create       254
#define __NR_epoll_ctl          255
#define __NR_epoll_wait         256
#define __NR_remap_file_pages   257
#define __NR_set_tid_address    258
#define __NR_timer_create       259
#define __NR_timer_settime      (__NR_timer_create+1)
#define __NR_timer_gettime      (__NR_timer_create+2)
#define __NR_timer_getoverrun   (__NR_timer_create+3)
#define __NR_timer_delete       (__NR_timer_create+4)
#define __NR_clock_settime      (__NR_timer_create+5)
#define __NR_clock_gettime      (__NR_timer_create+6)
#define __NR_clock_getres       (__NR_timer_create+7)
#define __NR_clock_nanosleep    (__NR_timer_create+8)
#define __NR_statfs64           268
#define __NR_fstatfs64          269
#define __NR_tgkill             270
#define __NR_utimes             271
#define __NR_fadvise64_64       272
#define __NR_vserver            273
#define __NR_mbind              274
#define __NR_get_mempolicy      275
#define __NR_set_mempolicy      276
#define __NR_kexec_load         283
#define __NR_waitid             284
/* #define __NR_sys_setaltroot  285 */
#define __NR_add_key            286
#define __NR_request_key        287
#define __NR_keyctl             288
#define __NR_ioprio_set         289
#define __NR_ioprio_get         290
#define __NR_inotify_init       291
#define __NR_inotify_add_watch  292
#define __NR_inotify_rm_watch   293
#define __NR_migrate_pages      294
#define __NR_openat             295
#define __NR_mkdirat            296
#define __NR_mknodat            297
#define __NR_fchownat           298
#define __NR_futimesat          299
#define __NR_fstatat64          300
#define __NR_unlinkat           301
#define __NR_renameat           302
#define __NR_linkat             303
#define __NR_symlinkat          304
#define __NR_readlinkat         305
#define __NR_fchmodat           306
#define __NR_faccessat          307
#define __NR_pselect6           308
#define __NR_ppoll              309
#define __NR_unshare            310
#define __NR_set_robust_list    311
#define __NR_get_robust_list    312
#define __NR_splice             313
#define __NR_sync_file_range    314
#define __NR_tee                315
#define __NR_dup3               330
#define __NR_pipe2              331
#line 3397 "../diss-hgesser-ulix.tex"
#define __NR_setpsname 0x5103
#line 3770 "../diss-hgesser-ulix.tex"
#define __NR_getpsinfo 0x5101
#line 8179 "../diss-hgesser-ulix.tex"
#define __NR_clrscr   0x6001
#define __NR_get_xy   0x6002
#define __NR_set_xy   0x6003
#line 8260 "../diss-hgesser-ulix.tex"
#define __NR_read_screen   0x6004
#define __NR_write_screen  0x6005
#line 17128 "../diss-hgesser-ulix.tex"
#define __NR_ls 0x5102
#line 3369 "../diss-hgesser-ulix.tex"
void update_statusline ();
#line 3555 "../diss-hgesser-ulix.tex"
void syscall_yield (struct regs_syscall *r);
#line 3615 "../diss-hgesser-ulix.tex"
#define false 0
#define true 1
short int inside_yield = false;
#line 5119 "../diss-hgesser-ulix.tex"
typedef struct {
} addr_space_descr;

#line 5135 "../diss-hgesser-ulix.tex"
#define MAX_ADDR_SPACES 1024

#line 5140 "../diss-hgesser-ulix.tex"
addr_space_descr addr_space_table[MAX_ADDR_SPACES];

#line 5153 "../diss-hgesser-ulix.tex"
typedef uint addr_space_id;

#line 5246 "../diss-hgesser-ulix.tex"
typedef struct {
  uint present         : 1;  //  0
  uint writeable       : 1;  //  1
  uint user_accessible : 1;  //  2
  uint pwt            :  1;  //  3
  uint pcd            :  1;  //  4
  uint accessed       :  1;  //  5
  uint dirty          :  1;  //  6
  uint zeroes         :  2;  //  8.. 7
  uint unused_bits    :  3;  // 11.. 9
  uint frame_addr     : 20;  // 31..12
} page_desc;
#line 5360 "../diss-hgesser-ulix.tex"
typedef struct {
   page_desc pds[1024];
} page_table;
#line 5408 "../diss-hgesser-ulix.tex"
typedef struct {
  uint present         : 1;  //  0
  uint writeable       : 1;  //  1
  uint user_accessible : 1;  //  2
  uint pwt            :  1;  //  3
  uint pcd            :  1;  //  4
  uint accessed       :  1;  //  5
  uint undocumented   :  1;  //  6
  uint zeroes         :  2;  //  8.. 7
  uint unused_bits    :  3;  // 11.. 9
  uint frame_addr     : 20;  // 31..12
} page_table_desc;
#line 5462 "../diss-hgesser-ulix.tex"
typedef struct {
   page_table_desc ptds[1024];
} page_directory;
#line 5539 "../diss-hgesser-ulix.tex"
page_directory kernel_pd  __attribute__ ((aligned (4096)));
page_table kernel_pt      __attribute__ ((aligned (4096)));

// prefer to work with pointers
page_directory* current_pd = &kernel_pd;
page_table*     current_pt = &kernel_pt;
#line 5898 "../diss-hgesser-ulix.tex"
page_table video_pt __attribute__ ((aligned (4096)));  /* must be aligned! */
#line 5986 "../diss-hgesser-ulix.tex"
#define MEM_SIZE 1024*1024*64        // 64 MByte
#define MAX_ADDRESS MEM_SIZE-1       // last valid physical address
#define PAGE_SIZE 4096               // Intel: 4K pages
#define NUMBER_OF_FRAMES MEM_SIZE/PAGE_SIZE
#line 6073 "../diss-hgesser-ulix.tex"
#define INDEX_FROM_BIT(b) (b/32)   // 32 bits in an uint
#define OFFSET_FROM_BIT(b) (b%32)
#line 6181 "../diss-hgesser-ulix.tex"
page_table kernel_pt_ram[16] __attribute__ ((aligned (4096)));
#line 6256 "../diss-hgesser-ulix.tex"
#define PHYSICAL(x) ((x)+0xd0000000)
#line 6280 "../diss-hgesser-ulix.tex"
/* Peek and Poke for virtual addresses */
#define PEEK(addr)      (*(unsigned char *)(addr))
#define POKE(addr, b)   (*(unsigned char *)(addr) = (b))
/* Peek and Poke for physical addresses 0..64 MB */
#define PEEKPH(addr)    (*(unsigned char *)(PHYSICAL(addr)))
#define POKEPH(addr, b) (*(unsigned char *)(PHYSICAL(addr)) = (b))
#define PEEKPH_UINT(addr)    (*(unsigned int *)(PHYSICAL(addr)))
#define POKEPH_UINT(addr, b) (*(unsigned int *)(PHYSICAL(addr)) = (b))

#line 6441 "../diss-hgesser-ulix.tex"
void print_page_table ();
#line 6726 "../diss-hgesser-ulix.tex"
#define NULL ((void*) 0)

#line 6818 "../diss-hgesser-ulix.tex"
short int DEBUG=0;
#line 7145 "../diss-hgesser-ulix.tex"
typedef struct kmalloc_header_struct {
  char magic_header[8];  // we'll put a magic string in here
  uint size;             // size of the allocated memory area
  uint reserved;         // for later use
  // gives a total of 16 bytes for the header
} kmalloc_header;
#line 7159 "../diss-hgesser-ulix.tex"
#define KMALLOC_HEADER "ULIX_KM"
#line 7473 "../diss-hgesser-ulix.tex"
typedef struct {
  void* pd;      // address of the page directory
  uint physical; // physical address of the page directory
  int pid;       // process ID (if used by a process or kernel thread; -1 if not)
  boolean free;  // are we using this address space?
  uint memstart; // first address below 0xc000.0000
  uint memend;   // last address below 0xc000.0000
  // FURTHER DATA? TYPE?
} address_space;
address_space address_spaces[MAX_ADDR_SPACES];
#line 7651 "../diss-hgesser-ulix.tex"
int as_map_page_to_frame (int as, uint pageno, uint frameno);
#line 7698 "../diss-hgesser-ulix.tex"
void destroy_address_space (int id);
#line 7756 "../diss-hgesser-ulix.tex"
inline void activate_address_space (int id)  __attribute__((always_inline));
int current_as = 0;  // global variable: current address space
#line 7800 "../diss-hgesser-ulix.tex"
void list_address_spaces ();
#line 7829 "../diss-hgesser-ulix.tex"
uint mmu (int id, uint vaddress);  // v-address -> phys-address
uint mmu_p (int id, uint pageno);  // pageno -> frameno
#line 7923 "../diss-hgesser-ulix.tex"
void *sbrk (int incr);
#line 8004 "../diss-hgesser-ulix.tex"
#define VT_SIZE 80*24*2
typedef struct {
  char mem[VT_SIZE];
  int x,y;
} term_buffer;
#line 8085 "../diss-hgesser-ulix.tex"
int vt_activate (int i);
#line 8092 "../diss-hgesser-ulix.tex"
short int KERNEL_VT = 0;
#line 8112 "../diss-hgesser-ulix.tex"
#define __NR_setterm  0x2001
#line 8127 "../diss-hgesser-ulix.tex"
void terminal_clrscr ();
void terminal_get_xy (char *x, char *y);
void terminal_set_xy (char x, char y);
#line 8224 "../diss-hgesser-ulix.tex"
void read_write_screen (char *buf, boolean read_flag);
void read_screen (char *buf);
void write_screen (char *buf);
#line 8842 "../diss-hgesser-ulix.tex"
typedef unsigned int thread_id;

#line 9355 "../diss-hgesser-ulix.tex"
typedef struct {
  thread_id next; // id of the ``next'' thread
  thread_id prev; // id of the ``previous'' thread
} blocked_queue;


#line 8846 "../diss-hgesser-ulix.tex"
void add(thread_id t);
void assign(int cpuid);
void block(int cpuid, blocked_queue* q); 
void deblock(thread_id t, blocked_queue* q);
void resign(int cpuid);
void retire(thread_id t);
#line 8935 "../diss-hgesser-ulix.tex"
#define GPR_REGISTERS 6   //       REMOVE THIS!!!!
#define EAX 0
#define EBX 1
#define ECX 2
#define EDX 3
#define ESI 4
#define EDI 5

#define CMDLINE_LENGTH 50   // how long can a process name be?
typedef struct {
  thread_id tid;
  thread_id ppid;   // parent process
  unsigned int context[GPR_REGISTERS]; // general purpose registers
  // unsigned int esp; // user stack pointer  ((brauch ich den???)
  unsigned int esp0; // kernel stack pointer
  unsigned int eip; // program counter
  unsigned int ebp; // base pointer
  char* kstack;
  addr_space_id addr_space;
  int state;
  struct regs regs;  // for the new implementation!!!!!!
  char cmdline[CMDLINE_LENGTH];
  
#line 3471 "../diss-hgesser-ulix.tex"
  int exitcode;
  int waitfor;    // in case of waitpid(): the pid of the child we wait for
#line 8049 "../diss-hgesser-ulix.tex"
int terminal;
#line 9295 "../diss-hgesser-ulix.tex"
thread_id next; // id of the ``next'' thread
thread_id prev; // id of the ``previous'' thread

#line 9531 "../diss-hgesser-ulix.tex"
boolean used;
#line 12296 "../diss-hgesser-ulix.tex"
boolean new;  // was this process freshly forked?
#line 14943 "../diss-hgesser-ulix.tex"
char cwd[256];
#line 17981 "../diss-hgesser-ulix.tex"
  sighandler_t sighandlers[32];
  unsigned long sig_pending;
  unsigned long sig_blocked;
#line 8958 "../diss-hgesser-ulix.tex"
} TCB;

#line 8975 "../diss-hgesser-ulix.tex"
#define MAX_THREADS 1024
TCB thread_table[MAX_THREADS];

#line 9054 "../diss-hgesser-ulix.tex"
thread_id schedule();
#line 9396 "../diss-hgesser-ulix.tex"
void add_to_ready_queue(thread_id t);
void remove_from_ready_queue(thread_id t);

#line 9439 "../diss-hgesser-ulix.tex"
void add_to_blocked_queue(thread_id t, blocked_queue* bq);
void remove_from_blocked_queue(thread_id t, blocked_queue* bq);
thread_id front_of_blocked_queue(blocked_queue bq);

#line 9922 "../diss-hgesser-ulix.tex"
typedef unsigned short u16int;
typedef struct {
   uint   prev_tss;   // Previous TSS
   uint   esp0;       // The stack pointer to load when we change to kernel mode.
   uint   ss0;        // The stack segment to load when we change to kernel mode.
   uint   esp1, ss1;  // Unused...
   uint   esp2, ss2;
   uint   cr3;
   uint   eip;
   uint   eflags;
   uint   eax, ecx, edx, ebx, esp, ebp, esi, edi;
   // Values to load into ES when switching to kernel mode
   uint   es, cs, ss, ds, fs, gs;
   uint   ldt;        // Unused...
   u16int trap;       // just the lowest bit
   u16int iomap_base;
} __attribute__((packed)) tss_entry_struct;

tss_entry_struct tss_entry;
#line 9956 "../diss-hgesser-ulix.tex"
static void write_tss(int num, u16int ss0, uint esp0);
#line 10008 "../diss-hgesser-ulix.tex"
extern void tss_flush();
#line 10153 "../diss-hgesser-ulix.tex"
#define boolean unsigned int
#define true 1
#define false 0
#define null 0
typedef unsigned char byte;  /* will use "byte" type */
#line 10206 "../diss-hgesser-ulix.tex"
extern void cpu_usermode(uint address, uint stack);  /* assembler */
#line 10215 "../diss-hgesser-ulix.tex"
char testprocess2[] __attribute__ ((aligned (4096))) = {
0xb8, 0xcd, 0xab, 0x00, 0x00, 0xcd, 0x80, 0xeb, 0xfe } ;
// 0xb8, 0xcd, 0xab, 0x00, 0x00, 0x90, 0x90, 0xeb, 0xfe } ;
//                            0x90=nop

// print "A"
char testprocess[] __attribute__ ((aligned (4096))) = {
0xb8, 0x01, 0x10, 0x00, 0x00, 0xbb, 0x41, 0x00, 0x00, 0x00,
0xcd, 0x80, 0xbb, 0x42, 0x00, 0x00, 0x00, 0xcd, 0x80, 

// 0xbb, 0x43, 0x00, 0x00, 0x00, 0xcd, 0x80, 0xbb, 

0xb8,
0x02, 0x10, 0x00, 0x00, 0xcd, 0x80, 0xb8, 0x01, 0x10, 0x00,
0x00, 0xcd, 0x80, 0xeb, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00 };

extern int printf(const char *format, ...);
extern int debug_printf(const char *format, ...);

void kernelprocess_a() {
  // print "A", syscall scheduler, repeat
  __asm__ ("\
    .intel_syntax noprefix; \
    starta: mov eax, 0x1001; \
    mov ebx, 'A'; \
    int 0x80; \
    mov eax, 0x9001; \
    int 0x80; \
    jmp starta; \
    .att_syntax; \
  ");
};

void kernelprocess_b() {
  // print "B", syscall scheduler, repeat
  __asm__ ("\
    .intel_syntax noprefix; \
    startb: mov eax, 0x1001; \
    mov ebx, 'B'; \
    int 0x80; \
    mov eax, 0x9001; \
    int 0x80; \
    jmp startb; \
    .att_syntax; \
  ");
};


void testprocess_func() {
  // uses syscall 0x5000 to restart shell. doesnt work yet
  // (shell starts, but faults on readline)

  //printf ("PEEK(0xd000.0000): ");
  //printf ("%d \n", PEEK(0xd0000000));
  
  // char st[21];
  // ureadline ((char*)&st, 20);
  //printf ((char*)&st);
  
  // kputch ('a');
  
  __asm__ ("\
    .intel_syntax noprefix; \
    label: ; \
    mov eax, 0x5000; \
    int 0x80; \
    mov eax,0x1002; \
    int 0x80; \
    mov eax,0x1001; \
    int 0x80; \
    mov eax, ebx; \
    int 0x80; \
    mov eax,0x1001; \
    mov ebx,'Z'; \
    int 0x80; \
    jmp label; \
    mov eax, 0x1001; \
    mov ebx, 0x43; \
    int 0x80; \
    mov ebx, 0x42; \
    int 0x80; \
    mov ebx, '\n'; \
    int 0x80; \
    mov eax, 0x5000; \
    int 0x80; \
    ret; \
    .att_syntax \
  ");

};

void switch_to_user_mode() {
   // ???? set_kernel_stack (0);
   // Set up a stack structure for switching to user mode.
   /*
   __asm__ __volatile__ ("  \
     cli; \
     mov   $0x23, %ax; \
     mov   %ax, %ds; \
     mov   %ax, %es; \
     mov   %ax, %fs; \
     mov   %ax, %gs; \
                   \
     mov   %esp, %eax; \
     pushl $0x23; \
     pushl %eax; \
     pushf; \
     pop   %eax; \
     orl   $0x200, %eax; \
     push  %eax; \
     pushl $0x1B; \
     push $1f; \
     iret; \
     1:\
     add   $4, %esp; \
   ");
   */
   
   
   /* code from http://articles.manugarg.com/systemcallinlinux2_6.html */
   /*
   __asm__ __volatile__ (" \
     movl $1f, %edx; \
     movl %esp, %ecx; \
     xorl %ebp,%ebp; \
     sti; \
     sysexit; \
     1: \
   ");
   */
   
   kputs ("TEST DONE\n");
   return;
}
#line 10361 "../diss-hgesser-ulix.tex"
void simple_shell();
#line 10365 "../diss-hgesser-ulix.tex"
// kernel stack (per process): 1 page = 4 KByte
#define KERNEL_STACK_PAGES 4
#define KERNEL_STACK_SIZE PAGE_SIZE * KERNEL_STACK_PAGES
#line 10413 "../diss-hgesser-ulix.tex"
volatile int current_task;

#line 10541 "../diss-hgesser-ulix.tex"
int find_free_TCB_entry ();
#line 10683 "../diss-hgesser-ulix.tex"
// Thread states
#define TSTATE_READY     1
#define TSTATE_FORK      3
#define TSTATE_EXIT      4
#define TSTATE_WAITFOR   5
#define TSTATE_ZOMBIE    6
#define TSTATE_WAITKEY   7   // wait for key press event
#define TSTATE_WAITFLP   8   // wait for floppy
#define TSTATE_LOCKED    9   // wait for lock
#define TSTATE_STOPPED  10   // stopped by SIGSTOP signal

char* state_names[9] = { "---", "READY", "---", "FORK", "EXIT", "WAIT4", "ZOMBY", "W_KEY", "W_FLP" };

int ulix_fork ();
void print_thread_table();
#line 10722 "../diss-hgesser-ulix.tex"
void inline copy_frame (int out, int in) __attribute__((always_inline));
#line 10885 "../diss-hgesser-ulix.tex"
extern uint get_eip();
#line 11576 "../diss-hgesser-ulix.tex"
struct kl_semaphore {
  int counter;
  blocked_queue bq;
  
#line 11689 "../diss-hgesser-ulix.tex"
boolean used; 

#line 11579 "../diss-hgesser-ulix.tex"
                                     // uninteresting implementation details
};

#line 11589 "../diss-hgesser-ulix.tex"
typedef int kl_semaphore_id;

#line 11604 "../diss-hgesser-ulix.tex"
kl_semaphore_id new_kl_semaphore(int k);
void release_kl_semaphore(kl_semaphore_id s);
#line 11676 "../diss-hgesser-ulix.tex"
#define MAX_SEMAPHORES 32
struct kl_semaphore kl_semaphore_table[MAX_SEMAPHORES];

#line 11925 "../diss-hgesser-ulix.tex"
typedef struct {
  short int l;       // the lock
  short int used;    // using this lock?
  blocked_queue bq;  // queue for this lock
} lock_t;
typedef lock_t* lock;

lock_t kernel_locks[100];
#line 12285 "../diss-hgesser-ulix.tex"
void scheduler ();
int scheduler_is_active = false;
#define ENABLE_SCHEDULER scheduler_is_active = true
#define DISABLE_SCHEDULER scheduler_is_active = false
#line 12304 "../diss-hgesser-ulix.tex"
TCB *t_old; static TCB *t_new;
#line 12360 "../diss-hgesser-ulix.tex"
int tmp_as;          // temporary address space variable, for context switching
int create_as = -1;  // this as is currently being created; do not modify AS
uint tmp_esp0;       // temporary kernel ESP value, for context switching
uint tmp_ebp;
#line 12399 "../diss-hgesser-ulix.tex"
#define DUMP_REGS debug_printf ("REGS: eax=%x, ebx=%x, ecx=%x, eip=%x,\n" \
  "REGS: ebp=%x esp=%x, useresp=%x, cs=%x, &r=%x\n", \
  r->eax, r->ebx, r->ecx, r->eip, r->ebp, r->esp, r->useresp, r->cs, r)
#define COPY_VAR_TO_ESP(x)  asm volatile ("mov %0, %%esp" :         : "r"(x) )
#define COPY_VAR_TO_EBP(x)  asm volatile ("mov %0, %%ebp" :         : "r"(x) )
#define COPY_ESP_TO_VAR(x)  asm volatile ("mov %%esp, %0" : "=r"(x)          )
#define COPY_EBP_TO_VAR(x)  asm volatile ("mov %%ebp, %0" : "=r"(x)          )
#define WRITE_CR3(x)        asm volatile ("mov %0, %%cr3" :         : "r"(x) )
#line 12441 "../diss-hgesser-ulix.tex"
#define BREAK asm ("xchg %bx,%bx");
#line 12620 "../diss-hgesser-ulix.tex"
typedef struct {
  char mountpoint[256];
  short fstype;     /* filesystem type, e.g. Minix, RAMfs */
  short device;     /* e.g. DEV_FD0, DEV_RAM0 */
  short mount_flags;
} mount_table_entry;

mount_table_entry mount_table[16];
#line 13181 "../diss-hgesser-ulix.tex"
#define BLOCK_SIZE 1024
#line 13188 "../diss-hgesser-ulix.tex"
typedef unsigned char         uint8_t;
typedef unsigned short       uint16_t;
typedef unsigned int         uint32_t;
typedef unsigned long long   uint64_t;
#line 13197 "../diss-hgesser-ulix.tex"
struct minix_superblock { 
  uint16_t s_ninodes;        uint16_t s_nzones; 
  uint16_t s_imap_blocks;    uint16_t s_zmap_blocks; 
  uint16_t s_firstdatazone;  uint16_t s_log_zone_size; 
  uint32_t s_max_size;       uint16_t s_magic; 
  uint16_t s_state;          uint32_t s_zones;
};
#line 13237 "../diss-hgesser-ulix.tex"
struct minix2_inode {
  
#line 13243 "../diss-hgesser-ulix.tex"
  uint16_t i_mode;           uint16_t i_nlinks;
  uint16_t i_uid;            uint16_t i_gid;
  uint32_t i_size;           uint32_t i_atime;
  uint32_t i_mtime;          uint32_t i_ctime;
  uint32_t i_zone[10];
#line 13239 "../diss-hgesser-ulix.tex"
};
#line 13296 "../diss-hgesser-ulix.tex"
struct minix_dir_entry {
  uint16_t inode;
  char name[30];
};
#line 13312 "../diss-hgesser-ulix.tex"
// void readblock (int blockno, char* block);
// void writeblock (int blockno, char* block);

// #define readblock kernel_read_sector
// #define writeblock kernel_write_sector

int fdc_read_sector(int device, int block, char* buffer);
#line 13948 "../diss-hgesser-ulix.tex"
void write_link (int inodenr, const char* filename);
#line 14019 "../diss-hgesser-ulix.tex"
int increase_link_count (int inodenr);
#line 14189 "../diss-hgesser-ulix.tex"
struct int_minix2_inode {
  
#line 13243 "../diss-hgesser-ulix.tex"
  uint16_t i_mode;           uint16_t i_nlinks;
  uint16_t i_uid;            uint16_t i_gid;
  uint32_t i_size;           uint32_t i_atime;
  uint32_t i_mtime;          uint32_t i_ctime;
  uint32_t i_zone[10];
#line 14190 "../diss-hgesser-ulix.tex"
                               // fields from the external inode
  int ino;                    // inode number
  unsigned int    refcount;   // how many users?
  unsigned short  clean;      // 0: changed; 1: unchanged (as on disk)
};

#define MAX_INT_INODES 256
struct int_minix2_inode inodes[MAX_INT_INODES] = { 0 };
#line 14715 "../diss-hgesser-ulix.tex"
#define BLOCKADDRESSES_PER_BLOCK BLOCK_SIZE / 4
#line 13885 "../diss-hgesser-ulix.tex"
void splitpath (const char *path, char *dirname, char *basename);
char *basename (char *path);
char *dirname (char *path);
#line 14231 "../diss-hgesser-ulix.tex"
#define O_RDONLY        0x0000     /* read only */
#define O_WRONLY        0x0001     /* write only */
#define O_RDWR          0x0002     /* read and write */
#define O_APPEND        0x0008     /* append mode */
#define O_CREAT         0x0200     /* create file */
#line 14241 "../diss-hgesser-ulix.tex"
#define S_IFIFO         0010000    /* named pipe (fifo) */
#define S_IFCHR         0020000    /* character device */
#define S_IFDIR         0040000    /* directory */
#define S_IFBLK         0060000    /* block device */
#define S_IFREG         0100000    /* regular file */
#define S_IFLNK         0120000    /* symbolic link */
#define S_IFSOCK        0140000    /* socket */
#line 14271 "../diss-hgesser-ulix.tex"
int pathname_to_ino (const char *path);
#line 14403 "../diss-hgesser-ulix.tex"
int mx_open (const char *path, int oflag);
int creat_empty_file (const char *path, int mode);  // later
#line 14524 "../diss-hgesser-ulix.tex"
int mx_close (int mfd);
#line 14584 "../diss-hgesser-ulix.tex"
#define	SEEK_SET	0	/* absolute offset */
#define	SEEK_CUR	1	/* relative offset */
#define	SEEK_END	2	/* EOF plus offset */
#line 14623 "../diss-hgesser-ulix.tex"
int mx_read (int mfd, void *buf, int nbyte);
int fileblocktozone (int blockno, struct int_minix2_inode *inode);
#line 14953 "../diss-hgesser-ulix.tex"
char *getcwd (char *buf, int size);
boolean file_exists (const char *path);
boolean file_is_directory (const char *path);
int chdir (const char *path);
#line 15043 "../diss-hgesser-ulix.tex"
int mx_link(const char *path1, const char *path2);
#line 15104 "../diss-hgesser-ulix.tex"
int mx_unlink (const char *path);
#line 15254 "../diss-hgesser-ulix.tex"
int mx_symlink (char *path1, char *path2);
#line 15398 "../diss-hgesser-ulix.tex"
int mx_mkdir(const char *path, int mode);
#line 15503 "../diss-hgesser-ulix.tex"
#define SECSIZE 1024

struct serial_disk_buffer_entry {
  int pid;                        // process ID; -1 if kernel
  short status;                   // New, Transfer, Finished, see BUF_STAT_*
  short direction;                // 100 = read, 101 = write
  uint secno;                     // sector number
  uint address;                   // memory address (in the process' address space)
  unsigned char sector[SECSIZE];  // 1024 bytes
};

#define BUF_STAT_NEW      0
#define BUF_STAT_TRANSFER 1
#define BUF_STAT_FINISHED 2
#define BUF_READ          100
#define BUF_WRITE         101

struct serial_disk_buffer_entry serial_disk_buffer[100];

int serial_disk_buffer_start = 0;   // initialize start and end of buffer usage
int serial_disk_buffer_end   = 0;   // interval in use is [start,end[, 
                                    // [0,0[ is empty
#line 15579 "../diss-hgesser-ulix.tex"
volatile int serial_disk_reader = 0;   // are we currently reading?
#line 15642 "../diss-hgesser-ulix.tex"
int kernel_read_sector (int secno, char* buf);
int kernel_write_sector (int secno, char* buf);
#line 15663 "../diss-hgesser-ulix.tex"
// Commands for the serial hard disk controller}
#define CMD_STAT   1   // status query
#define CMD_GET    2   // GET a sector (1024 bytes)
#define CMD_PUT    3   // PUT a sector (1024 bytes)
#define CMD_NUMSEC 4   // query: how many sectors?
#define CMD_TERM   99  // terminate controller
#line 16126 "../diss-hgesser-ulix.tex"
short int fdc_is_busy = false;
#line 16192 "../diss-hgesser-ulix.tex"
void fdc_timer(void);
#line 15858 "../diss-hgesser-ulix.tex"
#define ENXIO           6               /* Device not configured */
#define EBUSY           16              /* Device / Resource busy */
#define EINVAL          22              /* Invalid argument */
#define ESPIPE          29              /* Illegal seek */

#define PANIC printf

#define min(a,b) ((a) <= (b) ? (a) : (b))
#define max(a,b) ((a) >= (b) ? (a) : (b))

#define HZ 100
/* CHECK THIS VALUE! */


/**** from gnu/types.h ****/
typedef unsigned short __dev_t;
typedef long int __off_t;	/* Type of file sizes and offsets.  */


/**** from ioctl.h ****/
#define IOCTL_GETBLKSZ  0x00005480   /* Get device block size.  */
#define IOCTL_GETDEVSZ  0x00005481   /* Get device size (in no. of blocks).  */

/**** from buffer.h ****/
typedef struct {
  unsigned block         : 24,
           busy          : 1,
           in_demand     : 1,
           delayed_write : 1,
           valid         : 1,
           dedicated     : 1;

  __dev_t device;
  unsigned short size;

  unsigned char *address;

  unsigned short hprev;
  unsigned short hnext;

  unsigned short lprev;
  unsigned short lnext;

  unsigned short next;
  unsigned short __fill;
} buffer_t;

#define buf_address(buf_no)     buf_vect[buf_no].address


buffer_t *buf_vect;    /* from buffer.c */


/**** from include/thix/blkdrv.h ****/
typedef struct tag_br {
/*  int kid;    */              /* Kernel ID of the process.  */
    int blksz;                  /* File system block size.  */
    int block;                  /* First block. -1 means unused request.  */
    int nblocks;                /* Number of blocks.  */
    int buf_no;                 /* A list of buffers to receive data.  */
    struct tag_br *next;        /* Next request in the request list.  */
} blk_request;


/**** from dma.h ****/
#define DMA_CHANNELS            0x08

#define DMA0_STATUS             0x08
#define DMA0_INIT               0x0A
#define DMA0_MODE               0x0B
#define DMA0_FLIPFLOP           0x0C

#define DMA1_STATUS             0xD0
#define DMA1_INIT               0xD4
#define DMA1_MODE               0xD6
#define DMA1_FLIPFLOP           0xD8

#define DMA_READ_MODE           0x44
#define DMA_WRITE_MODE          0x48
#define DMA_VERIFY_MODE         0x40

/**** from floppy.h ****/

typedef int semaphore;   /* REMOVE THIS LATER */
typedef struct {         /* REMOVE THIS LATER */
  int in_use;                 /* In use flag.  */
  int mp;                     /* Index in mpt[].  */
  semaphore sync_mutex;       /* Semaphore used at sync time.  */
} minor_info;

#define ERR_BADREQ      error[0]

static char *error[] =
{
    "bad request",
};

#define WAIT_DEVICE_IO          54

#define FLOPPY_OUTPUT                   0x3f2

#define FLOPPY_CONTROLLER_ENABLE        0x04
#define FLOPPY_DMAINT_ENABLE            0x08

#define FLOPPY_STATUS                   0x3f4

#define FLOPPY_CONTROLLER_BUSY          0x10
#define FLOPPY_DMA_MODE                 0x20
#define FLOPPY_DIRECTION                0x40
#define FLOPPY_MASTER                   0x80
#define FLOPPY_NEW_BYTE                 (FLOPPY_MASTER         |   \
                                         FLOPPY_DIRECTION      |   \
                                         FLOPPY_CONTROLLER_BUSY)

#define FLOPPY_COMMAND                  0x3f5

#define FLOPPY_READ                     0xe6
#define FLOPPY_WRITE                    0xc5
#define FLOPPY_FORMAT                   0x4d
#define FLOPPY_RECALIBRATE              0x07
#define FLOPPY_SEEK                     0x0f
#define FLOPPY_SENSE                    0x08
#define FLOPPY_SPECIFY                  0x03

#define FLOPPY_RATE                     0x3f7
#define FLOPPY_INPUT                    0x3f7

#define FLOPPY_CHANGE_LINE              0x80
#define FLOPPY_CHANNEL                  0x02
#define FLOPPY_DTL                      0xFF

#define FLOPPY_SPEC2                    0x06

#define MAX_FLOPPY_RESULTS              0x07
#define MAX_FLOPPY_ERRORS               0x08

#define FLOPPY_TYPES                    0x03

#define TEST_BITS                       0xf8
#define SEEK_OK                         0x20
#define TRANSFER_OK                     0x00
#define WRITE_PROTECTED                 0x02

#define INVALID_TRACK                   -1

#define FDC_BLKSZ                       512

#define MAX_FDCS                        2


/*
 * fdc_buf is hard coded because the DMA needs it between 64k boundaries.
 * See vm_init() in mm.c for details.
 */

static char *fdc_buf = (char *)0x9a800;

static int  fdc_getresults(void);
static void fdc_out(unsigned char data);
static void fdc_surprise(void);

typedef struct {
  int total_sectors;
  int tracks;
  int sectors;
  int sectorsize;
  int trackstep;
  int rate;
  int gap;
  int spec1;
} struct_fdd_type;

typedef struct {
  int present;
  int calibrated;
  int motor;
  int current_track;
  int type;
} struct_fdd;

static int fdc_cmd;
static int fdc_drive;
static int fdc_track;
static int fdc_head;
static int fdc_sector;
static int fdc_nsects;
#line 16049 "../diss-hgesser-ulix.tex"
static semaphore fdc_oc_mutex = 1;
static semaphore fdc_rw_mutex = 1;
lock fdc_oc_lock;  // ULIX lock!
lock fdc_rw_lock;  // ULIX lock!

static volatile int fdc_ticks                  = 0;
static volatile int fdc_timeout                = 0;
static volatile int fdc_need_reset             = 0;
static volatile int fdc_waits_interrupt        = 0;
static volatile int fdc_ticks_till_motor_stops = 0;

// Es gibt auch 3.84 MB grosse Floppies, das Format ist wie
// bei den 2.88-ern, aber mit 48 statt 36 Sektoren, siehe
// http://www.infodrom.north.de/~joey/Linux/Tips+Tricks/floppy288.html


static char *fdd_drive_name[6] = {
  "not installed",
  "360K (not supported)",
  "1.2M",
  "720K (not supported)",
  "1.44M",
  "2.88M"
};

// muss fuer 2.88M evtl. noch die drive rate anpassen??

static struct_fdd_type fdd_type[FLOPPY_TYPES] = {
  { 80*15*2, 80, 15, 2, 0, 0, 0x1B, 0xDF },           /* 1.2M   */
  { 80*18*2, 80, 18, 2, 0, 0, 0x1B, 0xCF },           /* 1.44M  */
  { 80*36*2, 80, 36, 2, 0, 0, 0x1B, 0xAF },           /* 2.88M  */
};

static struct_fdd_type *current_fdd_type;

static struct_fdd fdd[2] = {
  { 0, 0, 0, INVALID_TRACK, 0 },
  { 0, 0, 0, INVALID_TRACK, 0 }
};

static struct_fdd *current_fdd;

static unsigned char fdc_results[MAX_FLOPPY_RESULTS];
static unsigned char current_OUTPUT;

static minor_info fdc_minor_info[2] = {
  { 0, 0, 1 },
  { 0, 0, 1 },
};


/*  RE-ENABLE THIS LATER?
static block_driver fdc_driver = {
  "floppy disk",
  fdc_open,
  fdc_close,
  fdc_read,
  fdc_write,
  NULL,
  fdc_ioctl,
  NULL,
  fdc_lseek,
  fdc_timer,
  FDC_MAJOR,
  FDC_IRQ,
  BLK_DRV,
  2,
  fdc_minor_info,
};
*/
#line 17111 "../diss-hgesser-ulix.tex"
#define SEEK_SET        0       /* set file offset, absolute */
#define SEEK_CUR        1       /* set file offset, relative */
#define SEEK_END        2       /* set file offset, EOF+offset */
#line 17139 "../diss-hgesser-ulix.tex"
#define EBADF 16
typedef unsigned short uint16;
typedef struct {
  char name[12];  // filename
  uint16 size;    // file size in bytes
  uint16 sector;  // start sector
} simplefs_fat_entry;
simplefs_fat_entry simplefs_fat[32];   // 32 files max.

typedef struct {
  short int used;       // are we using this entry?
  char name[12];        // filename
  uint16 size;          // file size in bytes
  uint16 sector;        // start sector
  unsigned int pos;     // seek position
} simplefs_openfiles_entry;
simplefs_openfiles_entry simplefs_openfiles[32];  // 32 open files
  
void simplefs_ls ();
int simplefs_open (char* filename);
int simplefs_close (int fd);
int simplefs_read (int fd, char* buf, int nbytes);
int simplefs_write (int fd, char* buf, int nbytes);
int simplefs_lseek(int fd, int offset, int whence);
#line 17370 "../diss-hgesser-ulix.tex"
int buffer_write (int dev, int blockno, char *block);
int buffer_read  (int dev, int blockno, char *block);
boolean buffer_contains (int dev, int blockno);
#line 18009 "../diss-hgesser-ulix.tex"
#define SIG_DFL ((sighandler_t)0)     /* default signal handling */
#define SIG_IGN ((sighandler_t)1)     /* ignore signal */
#define SIG_ERR ((sighandler_t)-1)    /* error code */
#line 18064 "../diss-hgesser-ulix.tex"
void kill (int pid, int signo);
#line 18151 "../diss-hgesser-ulix.tex"
sighandler_t signal (int sig, sighandler_t func);

#define SIGKILL  9
#define SIGSTOP 19
#line 18245 "../diss-hgesser-ulix.tex"
/* Defines a GDT entry */
struct gdt_entry
{
    unsigned short limit_low;
    unsigned short base_low;
    unsigned char base_middle;
    unsigned char access;
    unsigned char granularity;
    unsigned char base_high;
} __attribute__((packed));

struct gdt_ptr
{
    unsigned short limit;
    uint base;
} __attribute__((packed));

/* Our GDT, with 3 entries, and finally our special GDT pointer */
struct gdt_entry gdt[6];
struct gdt_ptr gp;

/* This is in start.asm. We use this to properly reload
*  the new segment registers */
extern void gdt_flush();
#line 18456 "../diss-hgesser-ulix.tex"
extern int printf(const char *format, ...);
extern int sprintf(const char *format, ...);
#line 18688 "../diss-hgesser-ulix.tex"
// I/O Addresses of the two programmable interrupt controllers
#define IO_PIC1         0x20    // Master (IRQs 0-7)
#define IO_PIC2         0xA0    // Slave (IRQs 8-15)

#define COM1    0x3f8
#define COM2    0x2f8
static int uart;    // is there a uart?
static int uart2;   // and a second uart?
#define IRQ_SLAVE       2       // IRQ at which slave connects to master
#define IRQ_COM1        4
#define IRQ_COM2        3


// Current IRQ mask.
// Initial IRQ mask has interrupt 2 enabled (for slave 8259A).
static unsigned short irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);

void microdelay (int us);
#line 18768 "../diss-hgesser-ulix.tex"
void uart2putc (int);
#line 18819 "../diss-hgesser-ulix.tex"
char serial_hard_disk_buffer[1024];
int serial_hard_disk_pos = 0;

#line 18882 "../diss-hgesser-ulix.tex"
int csr_x, csr_y;   // Cursor position
#line 18941 "../diss-hgesser-ulix.tex"
void move_csr(void);
#line 19163 "../diss-hgesser-ulix.tex"
uint VIDEORAM = 0xB8000;
void bochs_puts(char *text);
void set_statusline (char *text);
void _set_statusline (char *text, int offset);
void set_statusline_hex (uint i);
#line 19513 "../diss-hgesser-ulix.tex"
void kreadline (char *s, int maxlength);
#line 2640 "../diss-hgesser-ulix.tex"
blocked_queue keyboard_queue;   // processes which wait for a keystroke
#line 2738 "../diss-hgesser-ulix.tex"
short int FROM_KERNEL_MODE = false;   // timer handler will set this
                                      // to true if entered from kernel mode

#line 3439 "../diss-hgesser-ulix.tex"
blocked_queue waitpid_queue;
#line 6000 "../diss-hgesser-ulix.tex"
uint free_frames = NUMBER_OF_FRAMES;
#line 6010 "../diss-hgesser-ulix.tex"
char place_for_ftable[NUMBER_OF_FRAMES/8];
uint* ftable = (uint*)(&place_for_ftable);
#line 8019 "../diss-hgesser-ulix.tex"
#define MAX_VT 9
term_buffer vt[MAX_VT+1];
int cur_vt = 0;
#line 9029 "../diss-hgesser-ulix.tex"
#define NUM_CPUS 1   // MOVE THIS TO ANOTHER PLACE !!!
thread_id running[NUM_CPUS];
#line 9545 "../diss-hgesser-ulix.tex"
int next_pid = 1;
#line 10726 "../diss-hgesser-ulix.tex"
int INSIDE_FORK = false;    // FOR DEBUGGING, REMOVE LATER
#line 11714 "../diss-hgesser-ulix.tex"
kl_semaphore_id next_kl_semaphore = 0;

#line 15831 "../diss-hgesser-ulix.tex"
blocked_queue floppy_queue;   // processes which wait for the floppy
#line 17335 "../diss-hgesser-ulix.tex"
#define BUFFER_CACHE_SIZE 512

struct buffer_entry {
  char buf[BLOCK_SIZE];
  int dev;      // from what device?              (-1 if free)
  int blockno;  // block number of buffered block (-1 if free)
  byte count;   // how often was it read?
};

struct buffer_entry buffer_cache[BUFFER_CACHE_SIZE];
// struct buffer_entry *buffer_cache;

lock buffer_lock;
#line 1895 "../diss-hgesser-ulix.tex"
void print_cr0_cr3() {
  uint cr;
  __asm__ __volatile__("mov %%cr0, %0": "=r"(cr));
  kputs("cr0: "); printbits(cr); kputs ("\n");
  __asm__ __volatile__("mov %%cr3, %0": "=r"(cr));
  kputs("cr3: "); printbits(cr); kputs ("\n");
  return;
}
#line 2315 "../diss-hgesser-ulix.tex"
void page_fault_handler(struct regs *regs)
{
   // asm("hlt");
   // A page fault has occurred.
   // The faulting address is stored in the CR2 register.
   uint faulting_address;
   
   __asm__ __volatile__("mov %%cr2, %0" : "=r" (faulting_address));

   // The error code gives us details of what happened.
   int present   = !(regs->err_code & 0x1); // Page not present
   int rw = regs->err_code & 0x2;           // Write operation?
   int us = regs->err_code & 0x4;           // Processor was in user-mode?
   int reserved = regs->err_code & 0x8;     // Overwritten CPU-reserved bits of page entry?
   int id = regs->err_code & 0x10;          // Caused by an instruction fetch?

   // Output an error message.
   printf("Page fault! ( ");
   if (present) {printf("present ");}
   if (rw) {printf("read-only ");}
   if (us) {printf("user-mode ");}
   if (reserved) {printf("reserved ");}
   if (id) {printf("instruction-fetch ");}
   printf (")\n");

   bochs_puts ((char*)"page fault: address = ");
   bochs_printhex (faulting_address);
   bochs_putch ('\n');


   printf ("address = 0x%08x. current_task = %d. current_as = %d.\nHalting system.\n", 
     faulting_address, current_task, current_as);
   // int vreg;
   // asm volatile ("mov %%eax, %0" : "=r"(vreg)); printf ("eax: 0x%x\n", vreg);
   // asm volatile ("mov %%esp, %0" : "=r"(vreg)); printf ("esp: 0x%x\n", vreg);
   // asm volatile ("mov %%ebp, %0" : "=r"(vreg)); printf ("ebp: 0x%x\n", vreg);

   printf ("eax: %08x  ebx: %08x  ecx: %08x  edx: %08x \n",
     regs->eax, regs->ebx, regs->ecx, regs->edx);
   printf ("eip: %08x  esp: %08x  int: %8d  err: %8d \n", 
     regs->eip, regs->esp, regs->int_no, regs->err_code);
   printf ("ebp: %08x  cs: %d  ds: %d  es: %d  fs: %d  ss:%d \n",
     regs->ebp, regs->cs, regs->ds, regs->es, regs->fs, regs->ss);
   
   
   // FUNNY: JUST RESTART...
   DISABLE_SCHEDULER; 
   asm ("sti");
   printf ("\n");   
   asm ("jmp simple_shell");

   printf ("entering monitor\n");
   asm ("jmp monitor");
   
   __asm__ ("hlt");
   /*
   asm (".intel_syntax noprefix; \
     label2: \
     xchg ax,ax; \
     jmp label2; \
     .att_syntax");
   */
}

void sys_monitor () {
  uint v; int i;
  asm ("monitor: ");
  printf ("In Monitor\n");
  printf ("Stack:\n");
  for (i=0; i<10; i++) {
    asm (".intel_syntax noprefix; \
      pop eax; \
      .att_syntax" : : "r"(v));
    printf ("%08x\n",v);
  };  
  
  activate_address_space (1);
  printf ("ADDRESS SPACE 1:\n");
  hexdump (0,8191);
  activate_address_space (2);
  printf ("ADDRESS SPACE 2:\n");
  hexdump (0,8191);
  asm ("hlt");
}
#line 1949 "../diss-hgesser-ulix.tex"
unsigned char inportb (unsigned short _port) {
    unsigned char rv;
    __asm__ __volatile__ ("inb %1, %0" : "=a" (rv) : "dN" (_port));
    return rv;
}

unsigned short inportw (unsigned short _port) {
    unsigned short rv;
    __asm__ __volatile__ ("inw %w1, %w0" : "=a" (rv) : "Nd" (_port));
    return(rv);
}

void outportb (unsigned short _port, unsigned char _data) {
    __asm__ __volatile__ ("outb %1, %0" : : "dN" (_port), "a" (_data));
}

void outportw (unsigned short _port, unsigned short _data) {
    __asm__ __volatile__ ("outw %w0, %w1" : : "a" (_data), "Nd" (_port));
}
#line 2025 "../diss-hgesser-ulix.tex"
/* Use this function to set an entry in the IDT. A lot simpler
*  than twiddling with the GDT ;) */
void idt_set_gate(unsigned char num, unsigned long base, unsigned short sel, 
                  unsigned char flags)
{
    /* The interrupt routine's base address */
    idt[num].base_lo = (base & 0xFFFF);
    idt[num].base_hi = (base >> 16) & 0xFFFF;

    /* The segment or 'selector' that this IDT entry will use
    *  is set here, along with any access flags */
    idt[num].sel = sel;
    idt[num].always0 = 0;
    idt[num].flags = flags | 0x60;
    // 0x60 needed to set DPL to 3 (0x60 = 1100000(bin))
}

/* Installs the IDT */
void idt_install()
{
    /* Sets the special IDT pointer up, just like in 'gdt.c' */
    idtp.limit = (sizeof (struct idt_entry) * 256) - 1;
    idtp.base = (int) &idt;

    /* Clear out the entire IDT, initializing it to zeros */
    memset(&idt, 0, sizeof(struct idt_entry) * 256);

    /* Add any new ISRs to the IDT here using idt_set_gate */


    /* Points the processor's internal register to the new IDT */
    idt_load();
    __asm__ ("xchg %bx,%bx"); // bochs break point
}
#line 2066 "../diss-hgesser-ulix.tex"
/* These are own ISRs that point to our special IRQ handler
*  instead of the regular 'fault_handler' function */
extern void irq0();  extern void irq1();  extern void irq2();  extern void irq3();
extern void irq4();  extern void irq5();  extern void irq6();  extern void irq7();
extern void irq8();  extern void irq9();  extern void irq10(); extern void irq11();
extern void irq12(); extern void irq13(); extern void irq14(); extern void irq15();

/* This array is actually an array of function pointers. We use
*  this to handle custom IRQ handlers for a given IRQ */
void *irq_routines[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

/* This installs a custom IRQ handler for the given IRQ */
void irq_install_handler(int irq, void (*handler)(struct regs *r)) {
  irq_routines[irq] = handler;
}

/* This clears the handler for a given IRQ */
void irq_uninstall_handler(int irq) {
  irq_routines[irq] = 0;
}
#line 2099 "../diss-hgesser-ulix.tex"
void irq_remap(void) {
  outportb(0x20, 0x11);
  outportb(0xA0, 0x11);
  outportb(0x21, 0x20);
  outportb(0xA1, 0x28);
  outportb(0x21, 0x04);
  outportb(0xA1, 0x02);
  outportb(0x21, 0x01);
  outportb(0xA1, 0x01);
  outportb(0x21, 0x0);
  outportb(0xA1, 0x0);
}
#line 2119 "../diss-hgesser-ulix.tex"
void irq_install() {
    irq_remap();

    idt_set_gate(32, (unsigned)irq0, 0x08, 0x8E);
    idt_set_gate(33, (unsigned)irq1, 0x08, 0x8E);
    idt_set_gate(34, (unsigned)irq2, 0x08, 0x8E);
    idt_set_gate(35, (unsigned)irq3, 0x08, 0x8E);
    idt_set_gate(36, (unsigned)irq4, 0x08, 0x8E);
    idt_set_gate(37, (unsigned)irq5, 0x08, 0x8E);
    idt_set_gate(38, (unsigned)irq6, 0x08, 0x8E);
    idt_set_gate(39, (unsigned)irq7, 0x08, 0x8E);

    idt_set_gate(40, (unsigned)irq8, 0x08, 0x8E);
    idt_set_gate(41, (unsigned)irq9, 0x08, 0x8E);
    idt_set_gate(42, (unsigned)irq10, 0x08, 0x8E);
    idt_set_gate(43, (unsigned)irq11, 0x08, 0x8E);
    idt_set_gate(44, (unsigned)irq12, 0x08, 0x8E);
    idt_set_gate(45, (unsigned)irq13, 0x08, 0x8E);
    idt_set_gate(46, (unsigned)irq14, 0x08, 0x8E);
    idt_set_gate(47, (unsigned)irq15, 0x08, 0x8E);
}
#line 2155 "../diss-hgesser-ulix.tex"
void irq_handler(struct regs *r) {
    /* If the IDT entry that was invoked was greater than 40
    *  (meaning IRQ8 - 15), then we need to send an EOI to
    *  the slave controller */
    if (r->int_no >= 40) outportb(0xA0, 0x20);

    /* In either case, we need to send an EOI to the master
    *  interrupt controller too */
    outportb(0x20, 0x20);

    /// DEBUG
    /// printf ("IRQ Handler: No. %d \n", r->int_no-32);

    /* This is a blank function pointer */
    void (*handler)(struct regs *r);

    /* Find out if we have a custom handler to run for this
    *  IRQ, and then finally, run it */
    handler = irq_routines[r->int_no - 32];
    
    if (handler) {
      handler(r);
    }

}


/* These are function prototypes for all of the exception
*  handlers: The first 32 entries in the IDT are reserved
*  by Intel, and are designed to service exceptions! */

extern void isr0();  extern void isr1();  extern void isr2();
extern void isr3();  extern void isr4();  extern void isr5();
extern void isr6();  extern void isr7();  extern void isr8();
extern void isr9();  extern void isr10(); extern void isr11();
extern void isr12(); extern void isr13(); extern void isr14();
extern void isr15(); extern void isr16(); extern void isr17();
extern void isr18(); extern void isr19(); extern void isr20();
extern void isr21(); extern void isr22(); extern void isr23();
extern void isr24(); extern void isr25(); extern void isr26();
extern void isr27(); extern void isr28(); extern void isr29();
extern void isr30(); extern void isr31(); extern void isr128();

extern void isr129();  // call the scheduler; testing....


/* This is a very repetitive function... it's not hard, it's
*  just annoying. As you can see, we set the first 32 entries
*  in the IDT to the first 32 ISRs. We can't use a for loop
*  for this, because there is no way to get the function names
*  that correspond to that given entry. We set the access
*  flags to 0x8E. This means that the entry is present, is
*  running in ring 0 (kernel level), and has the lower 5 bits
*  set to the required '14', which is represented by 'E' in
*  hex. */

#define IDT_GATE(i) idt_set_gate(i, (unsigned)isr##i, 0x08, 0x8E)
// e.g.  idt_set_gate(31,(unsigned)isr31, 0x08, 0x8E)
void isrs_install() {
  IDT_GATE( 0); IDT_GATE( 1); IDT_GATE( 2); IDT_GATE( 3); IDT_GATE( 4);
  IDT_GATE( 5); IDT_GATE( 6); IDT_GATE( 7); IDT_GATE( 8); IDT_GATE( 9);
  IDT_GATE(10); IDT_GATE(11); IDT_GATE(12); IDT_GATE(13); IDT_GATE(14);
  IDT_GATE(15); IDT_GATE(16); IDT_GATE(17); IDT_GATE(18); IDT_GATE(19);
  IDT_GATE(20); IDT_GATE(21); IDT_GATE(22); IDT_GATE(23); IDT_GATE(24);
  IDT_GATE(25); IDT_GATE(26); IDT_GATE(27); IDT_GATE(28); IDT_GATE(29);
  IDT_GATE(30); IDT_GATE(31); IDT_GATE(128); IDT_GATE(129);
}

/* This is a simple string array. It contains the message that
*  corresponds to each and every exception. We get the correct
*  message by accessing like:
*  exception_message[interrupt_number] */
char *exception_messages[] = {
    "Division By Zero",             //  0
    "Debug",                        //  1
    "Non Maskable Interrupt",       //  2
    "Breakpoint",                   //  3
    "Into Detected Overflow",       //  4
    "Out of Bounds",                //  5
    "Invalid Opcode",               //  6
    "No Coprocessor",               //  7

    "Double Fault",                 //  8
    "Coprocessor Segment Overrun",  //  9
    "Bad TSS",                      // 10
    "Segment Not Present",          // 11
    "Stack Fault",                  // 12
    "General Protection Fault",     // 13
    "Page Fault",                   // 14
    "Unknown Interrupt",            // 15

    "Coprocessor Fault",            // 16
    "Alignment Check",              // 17
    "Machine Check",                // 18
    "Reserved", "Reserved", "Reserved", "Reserved", "Reserved",

    "Reserved", "Reserved", "Reserved", "Reserved", "Reserved",
    "Reserved", "Reserved", "Reserved"
};

/* All of our Exception handling Interrupt Service Routines will
*  point to this function. This will tell us what exception has
*  happened! Right now, we simply halt the system by hitting an
*  endless loop. All ISRs disable interrupts while they are being
*  serviced as a 'locking' mechanism to prevent an IRQ from
*  happening and messing up kernel data structures */
void fault_handler(struct regs *r)
{
   __asm__ ("xchg %bx,%bx");  // BOCHS debugger
   // uint faulting_address, eflags;
   // fault address is 2nd entry on the stack, see
   // http://stackoverflow.com/questions/10360888/
   // identifying-faulting-address-on-general-protection-fault-x86
   // __asm__ __volatile__("movl 4(%%esp), %%eax" : "=a" (faulting_address));
   // __asm__ __volatile__("movl 12(%%esp), %%eax" : "=a" (eflags));

    bochs_putch('X');
    if (r->int_no==14) page_fault_handler (r);
    
    if (r->int_no < 32) 
    {
        bochs_putch ('\n');
        bochs_puts(exception_messages[r->int_no]);
        bochs_puts(" Exception. System Halted!\n");
    
        kputs(exception_messages[r->int_no]);
        kputs(" Exception. System Halted!\n");
        
   printf ("address = 0x%08x. current_task = %d. current_as = %d.\nHalting system.\n", 
     r->eip, current_task, current_as);
   // int vreg;
   // asm volatile ("mov %%eax, %0" : "=r"(vreg)); printf ("eax: 0x%x\n", vreg);
   // asm volatile ("mov %%esp, %0" : "=r"(vreg)); printf ("esp: 0x%x\n", vreg);
   // asm volatile ("mov %%ebp, %0" : "=r"(vreg)); printf ("ebp: 0x%x\n", vreg);
   printf ("EFLAGS: 0x%08x; ERRCODE: 0x%08x\n", r->eflags, r->err_code);
   printf ("eax: %08x  ebx: %08x  ecx: %08x  edx: %08x \n",
     r->eax, r->ebx, r->ecx, r->edx);
   printf ("eip: %08x  esp: %08x  int: %8d  err: %8d \n", 
     r->eip, r->esp, r->int_no, r->err_code);
   printf ("ebp: %08x  cs: %d  ds: %d  es: %d  fs: %d  ss:%d \n",
     r->ebp, r->cs, r->ds, r->es, r->fs, r->ss);
        
        DISABLE_SCHEDULER; 
        asm ("sti");
        printf ("\n");   
        asm ("jmp simple_shell");

        __asm__ ("hlt");
    }
}
#line 2455 "../diss-hgesser-ulix.tex"
#define KEY_UP     191
#define KEY_DOWN   192
#define KEY_LEFT   193
#define KEY_RIGHT  194

unsigned char scancode_table[128] = {
  /*  0.. 9 */    0,  27, '1', '2', '3', '4', '5', '6', '7', '8',
  /* 10..19 */   '9', '0', '-', '=', '\b',	 /* Backspace */
                 '\t', /* Tab */   'q', 'w', 'e', 'r',	
  /* 20..29 */   't', 'z', 'u', 'i', 'o', 'p', '[', ']', 
                 '\n', /* Enter */  0, /* Control */
  /* 30..39 */   'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';',
  /* 40..49 */   '\'', '`', 0, /* Left shift */  '\\', 'y', 'x', 
                 'c', 'v', 'b', 'n',
  /* 50..59 */   'm', ',', '.', '/', 0, /* Right shift */
                 '*', 0, /* Alt */  ' ', /* Space bar */
                 0, /* CapsLock */  0, /* F1 */
  /* 60..69 */   0, 0, 0, 0, 0, 0, 0, 0, 0, /* F2..F10 */
                 0, /* NumLock */
  /* 70..79 */   0, /* Scroll Lock */   0, /* Home key */
                 KEY_UP, 0, /* Page Up */
                 '-', KEY_LEFT, 0, KEY_RIGHT,
                 '+', 0, /* End */
  /* 80..89 */   KEY_DOWN, 0, /* Page Down */
                 0, /* Insert Key */    0, /* Delete */
                 0, 0, 0, 0, /* F11 */  0, /* F12 */   0,
  /* 90..127     not defined */
};
#line 2495 "../diss-hgesser-ulix.tex"
void keyboard_handler(struct regs *r) {
  terminal_t *vt = &terminals[cur_vt];

  static boolean shift_pressed = false;
  static boolean left_shift_pressed = false;
  static boolean right_shift_pressed = false;
  static boolean alt_pressed = false;
  static boolean ctrl_pressed = false;
  unsigned char scancode, c;

  scancode = inportb(0x60);   // read from the data buffer
  
  if (scancode < 128) {
    c = scancode_table[scancode];
  }

  if (scancode & 0x80) {
    // release key event
    switch (scancode & ~0x80) {
      case 29: ctrl_pressed = false; break;
      case 42: left_shift_pressed = false; break;
      case 54: right_shift_pressed = false; break;
      case 56: alt_pressed = false; break;
    }
    shift_pressed = left_shift_pressed || right_shift_pressed;
  }  else {
    // press key event
    debug_printf ("KEYCODE: %d\n", scancode);
    switch (scancode) {
      case 29: ctrl_pressed = true; return;
      case 42: shift_pressed = left_shift_pressed = true; return;
      case 54: shift_pressed = right_shift_pressed = true; return;
      case 56: alt_pressed = true; return;
    }

    if ((scancode == 1) && shift_pressed) {
      // Shift+Escape pressed
      DISABLE_SCHEDULER; 
      asm ("sti");
      printf ("\n");
      asm ("jmp simple_shell");
      return;
    };


    // bochs cannot handle ALT key, so Esc is an extra ALT key for now...
    if (scancode == 1) {
      // Esc pressed (don't handle this any longer )
      alt_pressed = !alt_pressed;
      return;
    }

    // switch address spaces on keyboard input Shift-1, Shift-2, ..., Shift-9
    // DISABLED
    /*
    if (shift_pressed && ('0' <= c) && (c <= '9')) {
      for (int i=0; i<10; i++) {	
        if ((c == '0'+i) && (!address_spaces[i].free)) {
          char statusline[80];
          sprintf ((char*)&statusline, "Activating address space %d   ", i);
          set_statusline (statusline);
          activate_address_space(i);
          return;
        }
      };
    };
    */

    if (shift_pressed && ('0' <= c) && (c <= '9')) {
      char shiftkeys[] = "=!\"^$%&/()";
      c = shiftkeys[c-'0'];
    }

    // switch terminals via Alt-0 to Alt-9
    if ((alt_pressed) && ('0' <= c) && (c <= '9')) {
      vt_activate ((int)((c-'0')+9)%10);   // activate virtual console
      move_csr ();  // update cursor on new terminal
      return;
    };
    
#line 2585 "../diss-hgesser-ulix.tex"
if (vt->kbd_count < SYSTEM_KBD_BUFLEN) {
  if (shift_pressed && c>='a' && c<='z')  c-=32;     // Upper Case
  else if (ctrl_pressed && c>='a' && c<='z') c-=96;  // Ctrl
  vt->kbd[vt->kbd_pos] = c;
  vt->kbd_pos = (vt->kbd_pos + 1) % SYSTEM_KBD_BUFLEN;
  vt->kbd_count++;
  if ((vt->kbd_count == 1) && scheduler_is_active) {
    // debug_printf ("kbd handler: <waking sleeping process>\n");
    
#line 2608 "../diss-hgesser-ulix.tex"
thread_id start_pid = keyboard_queue.next;
if (start_pid != 0) {
  // only if there are queue entries...
  thread_id search_pid = start_pid;
  do {
    if (thread_table[search_pid].terminal == cur_vt) {
      thread_table[search_pid].state = TSTATE_READY;
      deblock (search_pid, &keyboard_queue);
      break;
    } else {
      search_pid = thread_table[search_pid].next;
    }
  } while (search_pid != start_pid && search_pid != 0);
}
#line 2594 "../diss-hgesser-ulix.tex"
    // debug_printf ("kbd handler: end <waking sleeping process>\n");
  }
}
#line 2575 "../diss-hgesser-ulix.tex"
  }
}
#line 2627 "../diss-hgesser-ulix.tex"
void keyboard_install() {
  irq_install_handler(1, keyboard_handler);
}
#line 2749 "../diss-hgesser-ulix.tex"
void timer_handler(struct regs *r) {
  char buf[9];
  char sched_chars[] = "|/-\\";
  static short sched_c = 0;
  short int sec,min,hour;
  
  
#line 2791 "../diss-hgesser-ulix.tex"
system_ticks++;    // one more timer interrupt
// system_time = (int) (system_ticks/18.222);    // original timer freq: 18.222 Hz
system_time = (int) (system_ticks/100);    // new timer freq: 100 Hz
#line 2801 "../diss-hgesser-ulix.tex"
if (system_ticks % 100 == 0) {          // Every 100 clocks (approx. 1 second) 
  hour = (system_time/60/60)%24;        // display the time
  min = (system_time/60)%60;
  sec = system_time%60;
  sprintf ((char*)&buf, "%02d:%02d:%02d", hour, min, sec);
  _set_statusline ((char*)&buf, 72);
}
#line 2815 "../diss-hgesser-ulix.tex"
// Every 2 clocks (approx. 1/9 second) call the scheduler
if (system_ticks % 2 == 0) {
/*
    // REMOVE THE FOLLOWING CODE
    // Don't do scheduling if we're in kernel mode
    if (r->eip >= 0xc0000000) {
      // printf ("timer: eip = %x, going to crash...\n", r->eip);
      FROM_KERNEL_MODE = true;
    } else {
      FROM_KERNEL_MODE = false;
    };
    // (END OF REMOVE)
*/

  // cycle |/-\\- to show scheduler calls in upper right corner
  uint videoaddress = VIDEORAM + 79*2;
  *((char*)videoaddress) = sched_chars[sched_c];
  sched_c++; sched_c %= 4;

  // only run the scheduler if a process hasn't just called yield():
  if (inside_yield == false) {
    // printf ("TIMER CALLING SCHEDULER!!!!\n\n\n");
    scheduler (r, SCHED_SRC_TIMER);  // defined in the process chapter
  }
};
#line 16198 "../diss-hgesser-ulix.tex"
fdc_timer ();

#line 2757 "../diss-hgesser-ulix.tex"
  // show current terminal, free frames, current_as
  sprintf ((char*)&buf, "tty%d  FF=%04x  AS=%04d", cur_vt, free_frames, current_as);
  _set_statusline ((char*)&buf, 48);  
}
#line 2766 "../diss-hgesser-ulix.tex"
void timer_phase(int hz) {
  // source: http://www.osdever.net/bkerndev/Docs/pit.htm
  int divisor = 1193180 / hz;       /* Calculate our divisor */
  outportb(0x43, 0x36);             /* Set our command byte 0x36 */
  outportb(0x40, divisor & 0xFF);   /* Set low byte of divisor */
  outportb(0x40, divisor >> 8);     /* Set high byte of divisor */
};
#line 2778 "../diss-hgesser-ulix.tex"
void timer_install() {
  timer_phase (100);   // set timer to 100 Hz (100 interrupts/second)
  irq_install_handler(0, timer_handler);
}
#line 2925 "../diss-hgesser-ulix.tex"
void insert_syscall (int syscallno, void* syscall_handler) {
  if (syscallno < MAX_SYSCALLS) {
    syscall_table[syscallno] = syscall_handler;
  }
  return;
};
#line 2944 "../diss-hgesser-ulix.tex"
void syscall_handler (struct regs_syscall *r) {
  /*
  printf ("ULIX syscall handler. Register: \n");
  printf ("address of regs: %x\n", &r);
  printf ("cs=%x, ds=%x, ss=%x, eip=%x, esp=%x, ebp=%x\n",
    r->cs, r->ds, r->ss, r->eip, r->esp, r->ebp);
  printf ("eflags=%x, useresp=%x\n",
    r->eflags, r->useresp);
  printf ("===========\n");
  */
  void (*handler) (struct regs_syscall*);   // handler is a function pointer
  int number = r->eax;
  handler = syscall_table[number];
  if (handler != 0) {
    handler (r);
  } else {
    printf("Unknown syscall no. eax=0x%x; ebx=0x%x. eip=0x%x, esp=0x%x. Continuing.\n", 
    r->eax, r->ebx, r->eip, r->esp);
  };
  
  if (number == __NR_fork)
    debug_printf ("DEBUG: syscall_handler: returning from fork syscall\n");
  return;
}
#line 3376 "../diss-hgesser-ulix.tex"
void syscall_fork (struct regs *r) {
  // int pid;
  // printf ("entering syscall fork\n");
  // pid = ulix_fork(r);
  // r->ebx = (uint)pid;
  r->ebx = (uint) ulix_fork(r);
  return;
};
#line 3390 "../diss-hgesser-ulix.tex"
void syscall_setpsname (struct regs *r) {
  memcpy (thread_table[current_task].cmdline, (char*)r->ebx, CMDLINE_LENGTH);
  return;
};
#line 3478 "../diss-hgesser-ulix.tex"
void syscall_waitpid (struct regs_syscall *r) {
  // ebx: pid of child to wait for
  // ecx: pointer to status
  // edx: options (ignored)
  int chpid = r->ebx;
  int *status = (int*)r->ecx;
  debug_printf ("[%d] in syscall_waitpid, status (1) = 0x%x\n", current_task, status);
  
  thread_table[current_task].state = TSTATE_WAITFOR;
  thread_table[current_task].waitfor = chpid;
  remove_from_ready_queue (current_task);
  add_to_blocked_queue (current_task, &waitpid_queue);

  printf ("[%d] waitpid: waiting for pid %d; calling scheduler \n", current_task, chpid);
  // syscall_yield (r);   // here we yield
  inside_yield = true;
  scheduler (r, SCHED_SRC_WAITFOR);
  
  /*
  if (thread_table[current_task].state != TSTATE_WAITFOR) {
    printf ("[%d] in syscall_waitpid: wrong return!\n", current_task);
    return;
  };
  */
    
  // asm ("int $0x81");  // call scheduler
  
  // PROBLEM
  // We come back here after scheduler(), but with the memory and
  // stack of a different thread. This is bad...
  
  inside_yield = false;

  printf ("waitpid: returned from yield (pid=%d)\n", current_task);

  // now we've returned from syscall_yield, the child must have
  // finished
  
  // unblocking this process happens in syscall_exit() !
  // remove_from_blocked_queue (current_task, &waitpid_queue);
  // add_to_ready_queue (current_task);
  
  // return value of waitpid is the process id of the terminated
  // child. We expect that syscall_exit() has updated the waitfor
  // field of the parent's TCB:
  chpid = thread_table[current_task].waitfor;
  if (chpid>0 && chpid<MAX_THREADS && thread_table[chpid].used) {
    debug_printf ("current_task = %d\n", current_task);
    debug_printf ("chpid = %d\n", chpid);
    r->eax = chpid;
  
    // the exitcode is in the child's exitcode field:
    // debug_printf ("in syscall_waitpid, status (2) = 0x%x\n", status);
    // debug_printf ("in syscall_waitpid. exitcode = %d\n", thread_table[chpid].exitcode);
    *status = thread_table[chpid].exitcode;
    // debug_printf ("in syscall_waitpid. *status = %d\n", *status);
  
    // now remove child process
    thread_table[chpid].used = false;
  } else {
    // *status = -1;
  }  
  debug_printf ("going to return from syscall_waitpid\n");
  return;
}
#line 3559 "../diss-hgesser-ulix.tex"
void syscall_exit (struct regs *r) {
  // printf ("DEBUG: syscall_exit. current_task = %d\n", current_task);
  // exit code is in ebx register:
  thread_table[current_task].exitcode = r->ebx;
  // mark thread as finished:
  thread_table[current_task].state = TSTATE_EXIT;
  // remove thread from ready list
  remove_from_ready_queue (current_task);
  
  // check if we need to wake up parent process
  int ppid = thread_table[current_task].ppid;
  if ( (thread_table[ppid].state == TSTATE_WAITFOR) &&
       (thread_table[ppid].waitfor == current_task) ) {
    // wake up parent process
    debug_printf ("exit: remove_from_blocked_queue (%d,%x)\n", ppid, &waitpid_queue);
    remove_from_blocked_queue (ppid, &waitpid_queue);
    add_to_ready_queue (ppid);
    thread_table[ppid].state = TSTATE_READY;   // mark parent as ready
    thread_table[current_task].state = TSTATE_EXIT;
    // thread_table[current_task].used = false;
  } else {
    // parent is not waiting, make this process a zombie
    thread_table[current_task].state = TSTATE_ZOMBIE;
  }
  
  // remove memory and destroy address space
  destroy_address_space (current_as);
  
  // finally: call scheduler to pick a different task

  // printf ("DEBUG: syscall_exit, going to int 0x81\n");

  // return;
  // asm ("int $0x81");
  // asm ("sti; hlt");
  asm ("sti");

  scheduler ((struct regs_syscall *)r, SCHED_SRC_YIELD);    

  printf ("ERROR: NEVER REACH THIS LINE!!!!\n\n");

  // better: call scheduler explicitly
};
#line 3621 "../diss-hgesser-ulix.tex"
void syscall_yield (struct regs_syscall *r) {
  debug_printf ("entering syscall_yield\n");
  debug_printf ("r->esp = %x  r->eip = %x\n", r->esp, r->eip);
  inside_yield = true;   // note: we have just started yield() and
                         // don't want to be interrupted by the scheduler

  scheduler (r, SCHED_SRC_YIELD);

  debug_printf("inside syscall_yield: back from scheduler ()\n");
  
  // we do not want to return here
  // instead, after entering scheduler() we expect to jump back
  // into the timer handler (???)
  
  // printf ("pid =%2d yield (post-sched) r->esp = %x\n",current_task, r->esp);

  // asm ("sti");
  inside_yield = false;
  return;
}
#line 3652 "../diss-hgesser-ulix.tex"
void syscall_getpid (struct regs_syscall *r) {
  r->eax = current_task;
  return;
};
#line 3666 "../diss-hgesser-ulix.tex"
void syscall_0x1001 (struct regs *r) {
  // put character
  char c = (unsigned char) (r->ebx);
  if (c>31 || c=='\n' || c==0x08) {
    kputch (c);
  } else {
    kputch ('^'); kputch (c+64);
  }
  return;
}
#line 3689 "../diss-hgesser-ulix.tex"
void syscall_0x1002 (struct regs *r) {
  char c;
  int t = thread_table[current_task].terminal;
  // t = 0;
  terminal_t *vt = &terminals[t];
  
  // get character
  // return 0 if there is no new character in the buffer
  if (vt->kbd_count > 0) {
    vt->kbd_count--;
    vt->kbd_lastread = (vt->kbd_lastread+1) % SYSTEM_KBD_BUFLEN;
    c = vt->kbd[vt->kbd_lastread];
  } else {
    c = 0;
    if ((current_task > 1) && scheduler_is_active) {
      // block process
      thread_table[current_task].state = TSTATE_WAITKEY;
      remove_from_ready_queue (current_task);
      add_to_blocked_queue (current_task, &keyboard_queue);
        
      // calling yield (via syscall 66)
      asm (".intel_syntax noprefix; \
        mov eax, 66;; \
        int 0x80;; \
        .att_syntax; ");
    }
    
  };
  // return value in ebx
  r->ebx = c;
  return;
};
#line 3734 "../diss-hgesser-ulix.tex"
void syscall_0x1111 (struct regs *r) {
  // readline
  // ebx: address of buffer
  // ecx: number of characters
  kreadline ((char*)r->ebx, (int)r->ecx);
  return;
};
#line 3774 "../diss-hgesser-ulix.tex"
void syscall_getpsinfo (struct regs *r) {
  uint retval, pid;
  // getpsinfo
  // ebx: number of process
  // ecx: address of TCB block

  pid = r->ebx;
  // legal argument?
  if (pid > MAX_THREADS || pid < 1) {
    retval = 0;
    goto end;
  }

  // do we have this process?
  if (thread_table[pid].used == false) {
    retval = 0;
    goto end;
  }
  
  // found a process: copy its TCB  
  memcpy ((char*)r->ecx, &thread_table[pid], sizeof(TCB));
  retval = r->ecx;

  end:
  r->eax = retval;
  return;
};
#line 7951 "../diss-hgesser-ulix.tex"
void syscall_brk (struct regs *r) {
  // ebx: increment
  r->eax = (uint)sbrk (r->ebx);
  return;
}
#line 8185 "../diss-hgesser-ulix.tex"
void syscall_clrscr (struct regs_syscall *r) {
  // no parameters, no return value
  terminal_clrscr ();
  return;
}

void syscall_get_xy (struct regs_syscall *r) {
  // ebx: address of x position (char)
  // ecx: address of y position (char)
  terminal_get_xy ((char*)r->ebx, (char*)r->ecx);
  return;
}

void syscall_set_xy (struct regs_syscall *r) {
  // ebx: x position (char)
  // ecx: y position (char)
  terminal_set_xy ((char)r->ebx, (char)r->ecx);
  return;
}
#line 8265 "../diss-hgesser-ulix.tex"
void syscall_read_screen (struct regs_syscall *r) {
  // ebx: buffer address
  read_write_screen ((char *) r->ebx, true); return;
}

void syscall_write_screen (struct regs_syscall *r) {
  // ebx: buffer address
  read_write_screen ((char *) r->ebx, false); return;
}
#line 15007 "../diss-hgesser-ulix.tex"
void syscall_getcwd (struct regs *r) {
  // ebx: buffer for directory
  // ecx: maximum length of path
  r->eax = (uint)getcwd ((char*)r->ebx, r->ecx);
}

void syscall_chdir (struct regs *r) {
  // ebx: new directory
  r->eax = chdir ((char*)r->ebx);
}
#line 15088 "../diss-hgesser-ulix.tex"
void syscall_link (struct regs *r) {
  // ebx: original name
  // ecx: new name
  r->eax = (uint)mx_link ((char*)r->ebx, (char*)r->ecx);
}
#line 15206 "../diss-hgesser-ulix.tex"
void syscall_unlink (struct regs *r) {
  // ebx: pathname
  r->eax = (uint)mx_unlink ((char*)r->ebx);
}
#line 15296 "../diss-hgesser-ulix.tex"
void syscall_symlink (struct regs *r) {
  // ebx: target file name
  // ecx: symbolic link name
  r->eax = (uint)mx_symlink ((char*)r->ebx, (char*)r->ecx);
}
#line 18085 "../diss-hgesser-ulix.tex"
void syscall_kill (struct regs *r) {
  // ebx: pid of child to send a s signal
  // ecx: signal number
  int ok, retval;
  int target_pid = r->ebx;
  int signo      = r->ecx;
  
  ok = true;
  
  // check if target process exists
  if (!thread_table[target_pid].used) {
    // target process does not exist
    retval = -1; goto end;
  }

  // check if signal is in range 0..31
  if (signo < 0 || signo > 31) {
    retval = -1; goto end;
  }
  
  
#line 18124 "../diss-hgesser-ulix.tex"
// TO DO!
// 
// 
ok = true;
#line 18106 "../diss-hgesser-ulix.tex"
  if (ok) {
    kill (target_pid, signo);
    retval = 0;
  } else
    retval = -1;
  
  end:
  r->eax = retval;

  
#line 18136 "../diss-hgesser-ulix.tex"
if (current_task == target_pid) {
  // calling yield (via syscall 66)
  asm (".intel_syntax noprefix; \
    mov eax, 66;; \
    int 0x80;; \
    .att_syntax; ");
}
#line 18116 "../diss-hgesser-ulix.tex"
  return;
};
#line 18174 "../diss-hgesser-ulix.tex"
void syscall_signal (struct regs *r) {
  // ebx: signal number
  // ecx: address of signal handler
  int signo         = r->ebx;
  sighandler_t func = (sighandler_t)r->ecx;

  signal (signo, func);
  r->eax = (uint)func;
  return;
};
#line 3750 "../diss-hgesser-ulix.tex"
void putch(unsigned char c) {
  // calls kputch via a syscall
  __asm__ (" \
	movl $0x1001,%%eax; \
	movl %0,%%ebx; \
	int  $0x80; \
	" : : "r"((uint)c) : "eax", "ebx");
};
#line 3872 "../diss-hgesser-ulix.tex"
#define memcpy_debug(dest, src, count) \
  debug_printf ("DEBUG: memcpy() called in line %d\n", __LINE__); \
  memcpy (dest, src, count);

void *memcpy (void *dest, const void *src, size_t count) {
  // debug_printf ("DEBUG: memcpy (%x,%x,%x)\n", dest, src, count);
  const char *sp = (const char *)src;
  char *dp = (char *)dest;
  for (; count != 0; count--) 
    *dp++ = *sp++;
  return dest;
}

void *strncpy (void *dest, const void *src, size_t count) {
  // like memcpy, but copies only until first \0 character
  const char *sp = (const char *)src;
  char *dp = (char *)dest;
  for (; count != 0; count--) {
    *dp = *sp;
    if (*dp == 0) break;
    dp++; sp++;
  }
  return dest;
}

/*  already defined elsewhere
int strlen (const char* str) {
  int len;
  while (*str++ != 0) 
    len++;
  return len;
}
*/

// the following is a memcpy wrapper which logs to bochs output
void *bochs_memcpy(void *dest, const void *src, size_t count) {
  bochs_puts ("memcpy: "); bochs_printhex ((uint)(dest));
  bochs_puts (" <- ");     bochs_printhex ((uint)(src));
  bochs_puts (", size: "); bochs_printhex ((uint)(count));
  bochs_putch ('\n');  
  return memcpy(dest, src, count);
}

void *memset(void *dest, char val, size_t count) {
  char *temp = (char *)dest;
  for( ; count != 0; count--) *temp++ = val;
  return dest;
}

unsigned short *memsetw(unsigned short *dest, unsigned short val, size_t count) {
  unsigned short *temp = (unsigned short *)dest;
  for( ; count != 0; count--) *temp++ = val;
  return dest;
}
#line 5265 "../diss-hgesser-ulix.tex"
uint page_desc_2_frame_address (page_desc pd) {
  uint address;
  /* pointer magic/cast: a page descriptor is not really an unsigned  *
   * int, but we want to treat it as one                              */
  address = *(uint*)(&pd);
  return address & 0xFFFFF000;   // set lowest 12 bits to zero
}
#line 5279 "../diss-hgesser-ulix.tex"
#define KMAP(pd,frame) fill_page_desc (pd, true, true, false, false, frame)
#define UMAP(pd,frame) fill_page_desc (pd, true, true, true,  false, frame)

page_desc* fill_page_desc (page_desc *pd, uint present,
                           uint writeable, uint user_accessible,
                           uint dirty, uint frame_addr) {
  // /--> pd: pointer to page descriptor <--/ //

  /*
  if (DEBUG) {
    kputs ("DEBUG: fill_page_desc:\n"); 
    kputs ("  vaddress: "); printhex ((uint)pd); putnl();
    kputs ("  frame:    "); printhex (frame_addr); putnl();

    if ((uint)pd==0x401000) {
      kputs ("WARNUNG! virtaddr. < 0xc0000000 \n");
    };
  };
  */
  
  // first fill the four bytes with zeros
  memset (pd, 0, sizeof(pd));
  
  // now enter the argument values in the right elements
  pd->present = present;
  pd->writeable = writeable;
  pd->user_accessible = user_accessible;
  pd->dirty = dirty;
  pd->frame_addr = frame_addr >> 12;   // right shift, 12 bits
    /* Note: This assumes that the frame address is well-formed, i.e., *
     * it has zeroes in its lowest 12 bits                             */
  return pd;
};
#line 5324 "../diss-hgesser-ulix.tex"
//
//
// THIS CODE DOES NOT WORK... WHY????
//
//


int map_page_to_frame (uint pageno, uint frameno) {
  int pdindex = pageno/1024;
  int ptindex = pageno%1024;
  if (! current_pd->ptds[pdindex].present) {
    // TODO: Pagetable nachladen/erzeugen, wenn nicht present!
    return false;
  } else {
    page_table* pt;
    // TODO:  Ummm, that's a pointer. Where's the memory for that page table?
    // 
    pt = (page_table*)(
      PHYSICAL(current_pd->ptds[pdindex].frame_addr << 12)
    );
    // fill_page_desc ( &(pt->pds[ptindex]), true, true, true, false,
    //  frameno << 12 );
    KMAP ( &(pt->pds[ptindex]), frameno << 12 );
    return true;
  };
}
#line 5427 "../diss-hgesser-ulix.tex"
uint page_table_desc_2_frame_address (page_table_desc ptd) {
  uint address;
  address = *(uint*)(&ptd);
  return address & 0xFFFFF000;
}
#line 5439 "../diss-hgesser-ulix.tex"
page_table_desc* fill_page_table_desc (page_table_desc *ptd, uint present,
                           uint writeable, uint user_accessible,
                           uint frame_addr) {
  // /--> ptd: pointer to page table descriptor <--/ //
  
  // first fill the four bytes with zeros
  memset (ptd, 0, sizeof(ptd));
  
  // now enter the argument values in the right elements
  ptd->present = present;
  ptd->writeable = writeable;
  ptd->user_accessible = user_accessible;
  ptd->frame_addr = frame_addr >> 12;   // right shift, 12 bits
  return ptd;
};

#define UMAPD(ptd, frame) fill_page_table_desc (ptd, true, true, true,  frame)
#define KMAPD(ptd, frame) fill_page_table_desc (ptd, true, true, false, frame)
#line 6081 "../diss-hgesser-ulix.tex"
static void set_frame(uint frame_addr)
{
   uint frame = frame_addr / PAGE_SIZE;
   uint index = INDEX_FROM_BIT(frame);
   uint offset = OFFSET_FROM_BIT(frame);
   ftable[index] |= (1 << offset);
}

static void clear_frame(uint frame_addr)
{
   uint frame = frame_addr / PAGE_SIZE;
   uint index = INDEX_FROM_BIT(frame);
   uint offset = OFFSET_FROM_BIT(frame);
   ftable[index] &= ~(1 << offset);
}
#line 6123 "../diss-hgesser-ulix.tex"
// Static function to test if a bit is set.
static uint test_frame(uint frame_addr) {
  // returns true if frame is in use (false if frame is free)
  uint frame = frame_addr / PAGE_SIZE;
  uint index = INDEX_FROM_BIT(frame);
  uint offset = OFFSET_FROM_BIT(frame);
  return ((ftable[index] & (0x1 << offset)) >> offset);
}
#line 6359 "../diss-hgesser-ulix.tex"
void print_page_directory () {
  int i;
  kputs ("The Page Directory:\n");
  for ( i = 700 ; i<800 ; i++ ) {
    if ( current_pd->ptds[i].present ) {
      printint (i); kputch (' ');
      printhex (current_pd->ptds[i].frame_addr );
      putnl();
      // pt = (uint*) kernel_pd.ptds[i].frame_addr;
      // kputs ("first entry's address: "); printhex(pt->pds[0].frame_addr); putnl();
    };
  };
  
  uint z=(uint)current_pd;
  // z = 0xd0401000;
  kputs ("hexdump for "); printhex (z); putnl();
  hexdump (z,z+128);
  putnl();
};
#line 6390 "../diss-hgesser-ulix.tex"
void print_page_table_helper (uint start, uint end, uint used) {
  if (used) {
    kputs ("Used: ");
  } else {
    kputs ("Free: ");
  }
  printf ("%05x-%05x    %5d-%5d   (%5d frames)\n", 
    start, end, start, end, end-start+1);
  //printhex (start); kputs ("-"); printhex (end); kputs ("    ");
  //printint (start); kputs ("-"); printint (end); 
  //kputs ("   ("); printint (end-start+1); kputs (" frames)\n");
  return;
};
#line 6414 "../diss-hgesser-ulix.tex"
uint pageno_to_frameno (uint pageno) {
  uint pdindex = pageno/1024;
  uint ptindex = pageno%1024;
  if ( ! current_pd->ptds[pdindex].present ) {
    // we don't have that page table
    return -1;
  } else {
    // get the page table
    page_table* pt = (page_table*)(
      PHYSICAL(current_pd->ptds[pdindex].frame_addr << 12)
      // note: frame_addr holds a physical address
      // luckily we have a mapping of physical address space 
      // to 0xd000.0000 and above...
    );
    if ( pt->pds[ptindex].present ) {
      return pt->pds[ptindex].frame_addr;
    } else {
      // we don't have that page
      return -1;
    };
  };    
};
#line 6445 "../diss-hgesser-ulix.tex"
void print_page_table () {
  uint cr3;
  
#line 6456 "../diss-hgesser-ulix.tex"
kputs ("Current Frame Info:\n");
// set_frame(2047*4096);  // use page 2047, TESTING
  
uint frameno = 0;
uint totalfree = NUMBER_OF_FRAMES;  // total number of free frames
uint test = test_frame(frameno*4096);  // check first frame
  
for (uint i=1; i<NUMBER_OF_FRAMES ; i++) {
  if (test_frame(i*4096) != test) { 
    print_page_table_helper (frameno, i-1, test);
    if (test) totalfree -= (i-frameno);
    test = 1-test;
    frameno = i;
  };
};
print_page_table_helper (frameno, NUMBER_OF_FRAMES-1, test);
if (test) totalfree -= (NUMBER_OF_FRAMES-frameno);
kputs ("Total free frames:    "); printint (totalfree); kputch ('\n');
kputs ("Value of free_frames: "); printint (free_frames); kputch ('\n');
#line 6448 "../diss-hgesser-ulix.tex"
  kputch ('\n');
  
#line 6500 "../diss-hgesser-ulix.tex"
printf ("Current Paging Info: Address Space #%d\n", current_as);

boolean started=false;
int save_i=0; int save_f=0; 
uint start_i=0; uint start_f=0;
for (uint i=0; i<1024*1024; i++) {
  frameno = mmu_p (current_as, i);  // get frameno with resp. to current AS
  if (frameno == -1) {
    // frame NOT found
    if (started) {
      
#line 6540 "../diss-hgesser-ulix.tex"
printf ("PTEs 0x%05x..0x%05x -> frames 0x%05x..0x%05x  (%5d pages)\n",
  start_i, save_i, start_f, save_f, save_i-start_i+1);
#line 6511 "../diss-hgesser-ulix.tex"
      started = false;
    }
    continue;  // dont act on non-mapped pages
  } else {
    // frame found
    if (!started) {
      start_i = i; start_f = frameno;
      save_i = i; save_f = frameno; // ???
      started = true;
    } else {
      if (i-start_i != frameno-start_f) {
        // pages continue, but frames are elsewhere
        
#line 6540 "../diss-hgesser-ulix.tex"
printf ("PTEs 0x%05x..0x%05x -> frames 0x%05x..0x%05x  (%5d pages)\n",
  start_i, save_i, start_f, save_f, save_i-start_i+1);
#line 6524 "../diss-hgesser-ulix.tex"
        start_i=i; start_f=frameno;
      };

      save_i = i;
      save_f = frameno;
    };
  };    
};
if (started) {
  
#line 6540 "../diss-hgesser-ulix.tex"
printf ("PTEs 0x%05x..0x%05x -> frames 0x%05x..0x%05x  (%5d pages)\n",
  start_i, save_i, start_f, save_f, save_i-start_i+1);
#line 6534 "../diss-hgesser-ulix.tex"
};
#line 6450 "../diss-hgesser-ulix.tex"
  __asm__ __volatile__("mov %%cr3, %0": "=r"(cr3));
  printf ("cr3: %08x\n", cr3);
}
#line 6560 "../diss-hgesser-ulix.tex"
void bochs_print_page_table_helper (uint start, uint end, uint used) {
  if (used) {
    bochs_puts ("Used: ");
  } else {
    bochs_puts ("Free: ");
  }
  bochs_printhex (start); bochs_puts ("-"); bochs_printhex (end); bochs_puts ("    ");
  bochs_printint (start); bochs_puts ("-"); bochs_printint (end); 
  bochs_puts ("   ("); bochs_printint (end-start+1); bochs_puts (" frames)\n");
  return;
};

void bochs_print_page_table () {
  
kputs ("Current Frame Info:\n");
// set_frame(2047*4096);  // use page 2047, TESTING
  
uint frameno = 0;
uint totalfree = NUMBER_OF_FRAMES;  // total number of free frames
uint test = test_frame(frameno*4096);  // check first frame
  
for (uint i=1; i<NUMBER_OF_FRAMES ; i++) {
  if (test_frame(i*4096) != test) { 
    bochs_print_page_table_helper (frameno, i-1, test);
    if (test) totalfree -= (i-frameno);
    test = 1-test;
    frameno = i;
  };
};
bochs_print_page_table_helper (frameno, NUMBER_OF_FRAMES-1, test);
if (test) totalfree -= (NUMBER_OF_FRAMES-frameno);
bochs_puts ("Total free frames:    "); bochs_printint (totalfree); bochs_putch ('\n');
bochs_puts ("Value of free_frames: "); bochs_printint (free_frames); bochs_putch ('\n');
  bochs_putch ('\n');
  
bochs_puts ("Current Paging Info:\n");

boolean started=false;
uint save_i=1;  uint save_f=0;  // some odd values
uint start_i=0; uint start_f=0;
for (uint i=0; i<1024*1024; i++) {
  frameno = pageno_to_frameno (i);
  if (frameno == -1) {
    // frame NOT found
    if (started) {

bochs_puts ("PTEs "); 
bochs_printhex (start_i); bochs_puts (".."); bochs_printhex (save_i); 
bochs_puts (" -> frames "); 
bochs_printhex (start_f); bochs_puts (".."); bochs_printhex (save_f);
bochs_puts ("   ("); bochs_printint (save_i-start_i+1); bochs_puts (" pages)\n");
      started = false;
    }
    continue;  // dont act on non-mapped pages
  } else {
    // frame found
    if (!started) {
      start_i = i; start_f = frameno;
      started = true;
    } else {
      if (i-start_i != frameno-start_f) {
        // pages continue, but frames are elsewhere
        
bochs_puts ("PTEs "); 
bochs_printhex (start_i); bochs_puts (".."); bochs_printhex (save_i); 
bochs_puts (" -> frames "); 
bochs_printhex (start_f); bochs_puts (".."); bochs_printhex (save_f);
bochs_puts ("   ("); bochs_printint (save_i-start_i+1); bochs_puts (" pages)\n");
        start_i=i; start_f=frameno;
      };

      save_i = i;
      save_f = frameno;
    };
  };    
};
if (started) {
  
bochs_puts ("PTEs "); 
bochs_printhex (start_i); bochs_puts (".."); bochs_printhex (save_i); 
bochs_puts (" -> frames "); 
bochs_printhex (start_f); bochs_puts (".."); bochs_printhex (save_f);
bochs_puts ("   ("); bochs_printint (save_i-start_i+1); bochs_puts (" pages)\n");
};
}
#line 6664 "../diss-hgesser-ulix.tex"
int request_new_frame () {
  
#line 6678 "../diss-hgesser-ulix.tex"
uint frameid;
boolean found=false;
for (frameid = 0; frameid < NUMBER_OF_FRAMES; frameid++) {
  if ( !test_frame (frameid*4096) ) {
    found=true;
    break;   // frame found
  };
}
#line 6690 "../diss-hgesser-ulix.tex"
if (found) {
  set_frame (frameid*4096);
  free_frames--;

  if (INSIDE_FORK) debug_printf ("in ulix_fork: request_new_frame() = %d\n", frameid);
 
  return frameid;
} else {
  return -1;
}
#line 6666 "../diss-hgesser-ulix.tex"
  // < < return frame id > >
};
#line 6708 "../diss-hgesser-ulix.tex"
void release_frame (uint frameaddr) {
  if ( test_frame (frameaddr) ) {
    // only do work if frame is marked as used
    clear_frame (frameaddr);
    free_frames++;
  };
};
#line 6729 "../diss-hgesser-ulix.tex"
uint* request_new_page (int need_more_pages) {
  // debug_printf ("ENTER request_new_page\n");
  uint newframeid = request_new_frame();
  // debug_printf ("AFTER request_new_frame\n");
  if (newframeid == -1)  return NULL;   // exit if no frame was found
  
#line 6749 "../diss-hgesser-ulix.tex"
// kputs ("Frame: "); printhex (newframeid);
uint pageno = -1;
for (uint i=0xc0000; i<1024*1024; i++) {

  /*
  *
  *  MAYBE: have a global variable NEXT_PAGE ??
  *  -> deal with problem of consecutive allocation
  *
  */
  // if ( pageno_to_frameno (i) == -1 ) {
  if ( mmu_p (current_as, i) == -1 ) {
    pageno = i;
    break;       // end loop, unmapped page was found
  };

};
// kputs (", Page: "); printhex (pageno);

// debug_printf ("debug: found page %x \n", pageno);

if ( pageno == -1 ) {
  // we found no page -- whole 4 GB are mapped???
  return NULL;
};
#line 6788 "../diss-hgesser-ulix.tex"
uint pdindex = pageno/1024;
uint ptindex = pageno%1024;
page_table* pt;

// printf ("debug: pdindex=%x, ptindex=%x\n", pdindex,ptindex);

if ( ptindex == 0 ) {    //  ACHTUNG! war: ptindex == 1023
  // last entry!!
  
#line 6959 "../diss-hgesser-ulix.tex"
debug_printf ("ENTER <create new page table>\n");
// create a new page table in there
page_table* pt = (page_table*) PHYSICAL(newframeid<<12);
memset (pt, 0, PAGE_SIZE);
#line 6972 "../diss-hgesser-ulix.tex"
/*
fill_page_table_desc (
  &(current_pd->ptds[pdindex]), // address of next page directory entry
  true, true, true,             // present, writeable, user_accessible
  newframeid << 12              // pointer to the page table 
);
*/
// UMAPD ( &(current_pd->ptds[pdindex]), newframeid << 12 );
#line 6987 "../diss-hgesser-ulix.tex"
int asid;
page_directory* tmp_pd;
for (asid=0; asid<1024; asid++) {
  debug_printf ("asid loop: asid = %d\n", asid);
  if (!address_spaces[asid].free   // is this address space in use?
      && asid != create_as)        // do not modify an address space which is cur-
                                   // rently created via create_new_address_space
  {
    tmp_pd = address_spaces[asid].pd;
    KMAPD ( &(tmp_pd->ptds[pdindex]), newframeid << 12 );
  }
}
debug_printf ("LEAVE <create new page table>\n");
#line 6797 "../diss-hgesser-ulix.tex"
  // update pageno and related variables (we'll use the next page)
  // OLD CODE: pageno+=1; pdindex = pageno/1024; ptindex = pageno%1024;

  // printf ("debug: after create new page table\n");

  // get yet another frame
  newframeid = request_new_frame();
  if (newframeid == -1) {
    return NULL;   // exit if no frame was found
    // note: we're not removing the new page table since we assume
    // it will be used soon anyway
  }
  // kputs (", 2nd frame: "); printhex (newframeid);
};
#line 6822 "../diss-hgesser-ulix.tex"
if ( ! current_pd->ptds[pdindex].present ) {
  // we don't have that page table -- this should not happen!
  kputs ("FAIL! No page table entry\n");
  debug_printf ("current_as = %d, create_as = %d\n", current_as, create_as);
  debug_printf ("&current_pd = 0x%x\n", &current_pd);
  debug_printf ("pdindex = %d, ptindex = %d\n", pdindex, ptindex);
  return NULL;
} else {
  // get the page table
  pt = (page_table*)(
    PHYSICAL(current_pd->ptds[pdindex].frame_addr << 12)
  );
  // finally: enter the frame address

  // kputs ("going to call fill_page_desc with adr = ");
  // printhex ((uint)&(pt->pds[ptindex])); putnl();
  
  // kputs ("DEBUG: pt->pds="); printhex ((uint)(&pt->pds[ptindex])); putnl();
  
  /*
  fill_page_desc (
    &(pt->pds[ptindex]),
    true, // present
    true, // writeable
    true, // user accessible
    false, // not dirty
    newframeid * PAGE_SIZE  // phys. addr.
  );
  */
  KMAP ( &(pt->pds[ptindex]), newframeid * PAGE_SIZE );

  // invalidate cache entry
  __asm__ __volatile__ ("invlpg %0" : : "m" (*(char*)(pageno<<12)));
};
#line 6861 "../diss-hgesser-ulix.tex"
memset ((uint*) (pageno*4096), 0, 4096);

// debug_printf ("LEAVE request_new_page\n");

return ((uint*) (pageno*4096));
#line 6735 "../diss-hgesser-ulix.tex"
  // debug_printf ("AFTER <enter frame in page table>\n");
};
#line 7019 "../diss-hgesser-ulix.tex"
void release_page (uint pageno) {
  
#line 7033 "../diss-hgesser-ulix.tex"
// int frameno = pageno_to_frameno (pageno);  // we will need this later
int frameno = mmu_p (current_as, pageno);  // we will need this later
if ( frameno == -1 )  return;              // exit if no such page
#line 7041 "../diss-hgesser-ulix.tex"
uint pdindex = pageno/1024;
uint ptindex = pageno%1024;
page_table* pt;

pt = (page_table*)(
    PHYSICAL(current_pd->ptds[pdindex].frame_addr << 12)
  );

// write null page descriptor
fill_page_desc ( &(pt->pds[ptindex]), false, false, false, false, 0 );
#line 7021 "../diss-hgesser-ulix.tex"
  
#line 7057 "../diss-hgesser-ulix.tex"
release_frame (frameno<<12);   // expects an address, not an ID
// note: release_frame increases free_frames
#line 7022 "../diss-hgesser-ulix.tex"
};
#line 7067 "../diss-hgesser-ulix.tex"
void release_page_range (uint start_pageno, uint end_pageno) {
  for (int i = start_pageno; i < end_pageno+1; i++ )  release_page (i);    
};
#line 7167 "../diss-hgesser-ulix.tex"
void* kmalloc (uint size) {
  kmalloc_header kmhead;                  // this is the header
  kmhead.size = size;                     // write size from kmalloc call
  memcpy (&kmhead, KMALLOC_HEADER, 8);    // 8 chars (including terminating 0)
  
  void* pointer;
  size += 16;                             // we need 16 extra bytes
  int count = (size-1)/PAGE_SIZE + 1;
  
#line 7186 "../diss-hgesser-ulix.tex"
uint old_free_frames = free_frames;

pointer = request_new_page (0);         // we need at least one page
while ( count > 1 ) {
  set_statusline_hex(count);
  request_new_page (0);                 // get another page if more is needed
  count--;
  };

printf ("Difference in free_frames: -%d.\n", -free_frames+old_free_frames);


#line 7177 "../diss-hgesser-ulix.tex"
  memcpy (pointer, &kmhead, 16);          // copy header into new memory
  return (void*)((uint)pointer + 16);     // return pointer, offset 16
};
#line 7214 "../diss-hgesser-ulix.tex"
void kfree (void* pointer) {
  kmalloc_header kmhead;                  // this is the header
  memcpy (&kmhead, pointer-16, 16);       // copy header from before pointer

  if ( !strcmp (KMALLOC_HEADER, (char*)&kmhead) ) {
    printf ("Error: p is not a kmalloc'ed area\n");
    return;
  }
#line 7229 "../diss-hgesser-ulix.tex"
  uint count = (kmhead.size+16-1)/PAGE_SIZE + 1;
  memcpy (pointer-16, "       ",8);  // copy 8 bytes
  uint old_free_frames = free_frames;
  printf ("kfree: Freeing %d pages.\n", count);
  uint page = ((uint)pointer - 16 ) / PAGE_SIZE;  // first page
  release_page_range (page, page+count-1);
  printf ("Difference in free_frames: %d.\n", free_frames-old_free_frames);

};
#line 7489 "../diss-hgesser-ulix.tex"
int get_free_address_space () {
  int id=0;
  while ((!address_spaces[id].free) && (id<MAX_ADDR_SPACES)) id++;
  if (id==MAX_ADDR_SPACES) id = -1;
  return id;
}
#line 7524 "../diss-hgesser-ulix.tex"
int create_new_address_space(int initial_ram) {
  // debug_printf ("ENTER create_new_address_space (%d)\n", initial_ram);
  int id = get_free_address_space ();
  if (id == -1) return -1;   // fail: no address space available
  address_spaces[id].free = false;
  // debug_printf ("BEFORE <reserve memory for pd>\n");
  create_as = id; // if set, this is the address space we currently create
  
#line 7574 "../diss-hgesser-ulix.tex"
debug_printf ("BEFORE request_new_page\n");
page_directory* new_pd = (void*)request_new_page (0);
debug_printf ("AFTER request_new_page\n");
if (new_pd == NULL) {
  // Error
  printf ("\nERROR: no free page, aborting create_new_address_space\n");
  return -1;
};
memset (new_pd, 0, sizeof(page_directory));
#line 7531 "../diss-hgesser-ulix.tex"
                                              // sets new_pd
  create_as = -1;  // (reset create_as)
  // debug_printf ("AFTER <reserve memory for pd>\n");
  address_spaces[id].pd = new_pd;
  address_spaces[id].physical = mmu( 0, (uint)new_pd );
  
#line 7589 "../diss-hgesser-ulix.tex"
bochs_memcpy (new_pd, &kernel_pd, sizeof(page_directory));

// now make a copy of the first page table as well and link it
page_table* new_pt = (void*) request_new_page (0);
if (new_pt == NULL) {
  // Error
  printf ("\nERROR: no free page, aborting create_new_address_space\n");
  return -1;
};
// printf ("new_pt: 0x%x, mmu(): 0x%x\n", (uint)new_pt, mmu(0,(uint)new_pt));
memcpy (new_pt, (void*) PHYSICAL(kernel_pd.ptds[0].frame_addr << 12), sizeof(page_table));
// printf ("begin UMAPD 0x%x,0x%x\n", &new_pd->ptds[0], mmu (0, (uint)new_pt) );
UMAPD ( &new_pd->ptds[0], mmu (0, (uint)new_pt) );
// printf ("end UMAPD\n");
#line 7537 "../diss-hgesser-ulix.tex"
  if (initial_ram > 0) {
    // make initial_ram a multiple of PAGE_SIZE
    initial_ram = ((initial_ram+PAGE_SIZE-1)/PAGE_SIZE)*PAGE_SIZE;
    
    address_spaces[id].memstart = 0;
    address_spaces[id].memend   = initial_ram;
    
    int frameno;
    int pageno = 0;
    while (initial_ram > 0) {
      if ( (frameno = request_new_frame ()) < 0) {
        // error
        printf ("\nERROR: no free frame, aborting create_new_address_space\n");
        return -1;
      };
      as_map_page_to_frame (id, pageno, frameno);
      pageno++;
      initial_ram-=PAGE_SIZE;
    };
  };
  // debug_printf ("LEAVE create_new_address_space (%d)\n", initial_ram);
  return id;
};
#line 7657 "../diss-hgesser-ulix.tex"
int as_map_page_to_frame (int as, uint pageno, uint frameno) {
  // for address space as, map page #pageno to frame #frameno
  // printf ("DEBUG: as_map_page_to_frame (%d,0x%x,0x%x)\n", as, pageno, frameno);
  page_table* pt;
  page_directory* pd;

  pd = address_spaces[as].pd;   // use the right address space
  uint pdindex = pageno/1024;   // calculuate pd entry
  uint ptindex = pageno%1024;   // ... and pt entry

  if ( ! pd->ptds[pdindex].present ) {
    // page table is not present
    pt = NULL;
    
    printf ("ERROR: create new page table not implemented\n"); // REMOVE
    return -1;
  } else {
    // get the page table
    // printf ("DEBUG: frame number of page table: 0x%x\n", pd->ptds[pdindex].frame_addr);
    pt = (page_table*) PHYSICAL(pd->ptds[pdindex].frame_addr << 12);
  };
  UMAP ( &(pt->pds[ptindex]), frameno << 12 );
  // ??? hier evtl. KMAP statt UMAP? Unterscheiden, ob <c000.0000 oder nicht?
  return 0;
};
#line 7702 "../diss-hgesser-ulix.tex"
void destroy_address_space (int id) {
  debug_printf ("ENTER destroy_address_space (%d)\n", id);
  debug_printf ("      memstart: %d\n", address_spaces[id].memstart);
  debug_printf ("      memend  : %d\n", address_spaces[id].memend);

  int as = current_as;  // remember the current address space
  current_as = id;

  // TODO: release all pages used by this process
  debug_printf ("free_frame: %d\n", free_frames);
  for ( int i = address_spaces[id].memstart / PAGE_SIZE;
        i < address_spaces[id].memend / PAGE_SIZE;
        i++ ) {
    debug_printf ("release: page %d\n", i);
    memset ((void*)(i<<12), 0, PAGE_SIZE);
    release_page (i);
  };
  debug_printf ("free_frame: %d\n", free_frames);
  
  // TODO: remove kernel stack
  // (cannot do this here, this kernel stack is in use right now)
  // ( -> scheduler )
  
  // TODO: remove reference to kernel memory  
  // (same problem)
  
  current_as = as;
  address_spaces[id].free = true;
  return;
}
#line 7761 "../diss-hgesser-ulix.tex"
inline void activate_address_space (int id) {
  // NOTE: Do not call this from the scheduler;
  //       where needed, replicate the code
  
  // We need to store id in a global variable because we switch the
  // address space
  tmp_as = id;
  
  if (tmp_as == 0) {
    debug_printf ("WARNING: activate_address_space (0) called!\n");
  } else {
    debug_printf ("NOTICE:  activate_address_space (%d) called!\n", tmp_as);
  }

  uint mem  = mmu(0, (uint)address_spaces[tmp_as].pd);
  __asm__ __volatile__ ("mov %0, %%cr3" : : "r"(mem)); // write CR3

  current_as = tmp_as;
  current_pd = address_spaces[tmp_as].pd;  // need this?
  return;
};
#line 7804 "../diss-hgesser-ulix.tex"
void list_address_space (int id) {
  int mem  = (uint) address_spaces[id].pd;
  int phys = mmu (id, (uint) address_spaces[id].pd);  // emulate MMU
  int memstart = address_spaces[id].memstart;
  int memend = address_spaces[id].memend;
  printf ("ID: %d, MEM: %08x, PHYS: %08x  - USER: [%08x..%08x[\n", 
    id, mem, phys, memstart, memend); 
};

void list_address_spaces () {
  int id;
  for (id=0; id<MAX_ADDR_SPACES; id++) {
    if (!address_spaces[id].free) {
      list_address_space (id);
    }
  }
};
#line 7840 "../diss-hgesser-ulix.tex"
uint mmu (int id, uint vaddress) {
  uint pageno, frameno, offset, pdindex, ptindex;
  page_directory* pd;
  page_table* pt;
  offset = vaddress%PAGE_SIZE;
  pageno = vaddress/PAGE_SIZE;
  pdindex = pageno/1024;
  ptindex = pageno%1024;
  pd = address_spaces[id].pd;
  if ( ! pd->ptds[pdindex].present ) {
    return -1;
  }
  pt = (page_table*) PHYSICAL(pd->ptds[pdindex].frame_addr << 12);
  if ( pt->pds[ptindex].present) {
    frameno = pt->pds[ptindex].frame_addr;
    return (frameno << 12) + offset;
  } else {
    return -1;
  };
};

uint mmu_p (int id, uint pageno) {
  // the same, but with page numbers returns framer number
  uint pdindex, ptindex;
  page_directory* pd;
  page_table* pt;
  pdindex = pageno/1024;
  ptindex = pageno%1024;
  pd = address_spaces[id].pd;
  if ( ! pd->ptds[pdindex].present ) {
    return -1;
  } else {
    pt = (page_table*) PHYSICAL(pd->ptds[pdindex].frame_addr << 12);
    if ( pt->pds[ptindex].present) {
      return pt->pds[ptindex].frame_addr;
    } else {
      return -1;
    };
  }
};

#line 7927 "../diss-hgesser-ulix.tex"
void *sbrk (int incr) {
  int pages = incr / PAGE_SIZE;
  int i, frame;
  address_space *aspace = &address_spaces[current_as];
  // page_table *pt = (page_table *)aspace->pd;

  uint oldbrk = aspace->memend;
    
  for (i=0; i<pages; i++) {
    frame = request_new_frame ();
    as_map_page_to_frame (current_as, aspace->memend/PAGE_SIZE, frame);
    aspace->memend += PAGE_SIZE;
  }
  return (void*) oldbrk;  
}
#line 8065 "../diss-hgesser-ulix.tex"
int vt_activate (int i) {
  if (i<0 || i>MAX_VT)
    return -1;    // no such console
  else {
    int old_vt = cur_vt;
    // handle screen part
    memcpy (vt[cur_vt].mem, (void*)VIDEORAM, VT_SIZE);  // store old stuff (remove)
    vt[cur_vt].x = csr_x; vt[cur_vt].y = csr_y; 
    memcpy ((void*)VIDEORAM, vt[i].mem, VT_SIZE);
    cur_vt = i;
    csr_x = vt[i].x;
    csr_y = vt[i].y;
    move_csr();
  }
}
#line 8099 "../diss-hgesser-ulix.tex"
void syscall_setterm (struct regs* r) {
  int vt = r->ebx;                  // argument in ebx register
  if (vt<0 || vt>MAX_VT) return;    // check if proper number...
  thread_table[current_task].terminal = vt;
  debug_printf ("DEBUG: current_task = %d\n", current_task);
  debug_printf ("DEBUG: terminal     = %d\n", vt);
  return;
};
#line 8137 "../diss-hgesser-ulix.tex"
void terminal_clrscr () {
  int process_term = thread_table[current_task].terminal;
  unsigned short* memptr;
  unsigned blank = 0x20 + (0x0f<<8); // blank character
  memptr = (unsigned short*)vt[process_term].mem;
  memsetw (memptr, blank, 80*24);
  terminal_set_xy (0, 0);
  
  // current terminal?
  if (process_term == cur_vt)
    memsetw ((void*)VIDEORAM, blank, 80*24);
  return;
}
#line 8157 "../diss-hgesser-ulix.tex"
void terminal_get_xy (char *x, char *y) {
  int process_term = thread_table[current_task].terminal;
  *x = vt[process_term].x;
  *y = vt[process_term].y;
}

void terminal_set_xy (char x, char y) {
  int process_term = thread_table[current_task].terminal;
  vt[process_term].x = x;
  vt[process_term].y = y;
  
  // current terminal?
  if (process_term == cur_vt) {
    csr_x = x; csr_y = y;
    move_csr();
  }
}
#line 8230 "../diss-hgesser-ulix.tex"
void read_write_screen (char *buf, boolean read_flag) {
  // if read_flag == true: read from screen, otherwise write
  int process_term = thread_table[current_task].terminal;
  char *video_address = (char*) vt[process_term].mem;
  
  if (read_flag) {
    // read the screen
    memcpy (buf, video_address, 80*24*2);
  } else {
    // write the screen
    memcpy (video_address, buf, 80*24*2);
    // current terminal?
    if (process_term == cur_vt)
      memcpy ((char*)VIDEORAM, video_address, 80*24*2);
  }
}

void read_screen (char *buf) {
  read_write_screen (buf, true);
}

void write_screen (char *buf) {
  read_write_screen (buf, false);
}
#line 9059 "../diss-hgesser-ulix.tex"
thread_id schedule() {
  return 0;
};
#line 9374 "../diss-hgesser-ulix.tex"
void initialize_blocked_queue(blocked_queue* q) {
  q->prev = 0;
  q->next = 0;
}
#line 9403 "../diss-hgesser-ulix.tex"
void add_to_ready_queue(thread_id t) {
  thread_id last = thread_table[0].prev;
  thread_table[0].prev = t;
  thread_table[t].next = 0;
  thread_table[t].prev = last;
  thread_table[last].next = t;
}

#line 9414 "../diss-hgesser-ulix.tex"
void remove_from_ready_queue(thread_id t) {
  thread_id prev_thread = thread_table[t].prev;
  thread_id next_thread = thread_table[t].next;
  thread_table[prev_thread].next = next_thread;
  thread_table[next_thread].prev = prev_thread;
}

#line 9449 "../diss-hgesser-ulix.tex"
thread_id front_of_blocked_queue(blocked_queue bq) {
  return bq.next;
}

#line 9460 "../diss-hgesser-ulix.tex"
void add_to_blocked_queue(thread_id t, blocked_queue* bq) {
  thread_id last = bq->prev;
  bq->prev = t;
  thread_table[t].next = 0; // [[t]] is ``last'' thread
  thread_table[t].prev = last;
  if (last == 0) {
    bq->next = t;
  } else {
    thread_table[last].next = t;
  }
}

#line 9476 "../diss-hgesser-ulix.tex"
void remove_from_blocked_queue(thread_id t, blocked_queue* bq) {
  thread_id prev_thread = thread_table[t].prev;
  thread_id next_thread = thread_table[t].next;
  if (prev_thread == 0) {
    bq->next = next_thread;
  } else {
    thread_table[prev_thread].next = next_thread;
  }
  if (next_thread == 0) {
    bq->prev = prev_thread;
  } else {
    thread_table[next_thread].prev = prev_thread;
  }
}

#line 9575 "../diss-hgesser-ulix.tex"
int register_new_tcb (int as_id) {
  
#line 9549 "../diss-hgesser-ulix.tex"
boolean tcbfound = false;
int tcbid;
for ( tcbid=next_pid; ((tcbid<MAX_THREADS) && (!tcbfound)); tcbid++ ) {
  if (thread_table[tcbid].used == false) {
    tcbfound = true;
    break;
  }
};
// continue searching at 1
if (!tcbfound) {
  for ( tcbid=1; ((tcbid<next_pid) && (!tcbfound)); tcbid++ ) {
    if (thread_table[tcbid].used == false) {
      tcbfound = true;
      break;
    }
  };
};
// update next_pid:
if (tcbfound) next_pid = tcbid+1;
// either tcbfound == false or tcbid == index of first free TCB
#line 9577 "../diss-hgesser-ulix.tex"
  if (!tcbfound) {
    return -1; // no free TCB!
  };
  thread_table[tcbid].used = true;         // mark as used
  thread_table[tcbid].addr_space = as_id;  // enter address space ID
  return tcbid;
}  
#line 9607 "../diss-hgesser-ulix.tex"
void add(thread_id t) {
  add_to_ready_queue(t);
}
void retire(thread_id t) {
  remove_from_ready_queue(t);
}

void deblock(thread_id t, blocked_queue* q) {
  remove_from_blocked_queue(t, q);
  add_to_ready_queue(t);
}
#line 9640 "../diss-hgesser-ulix.tex"
void resign(int cpuid) {
  
#line 9654 "../diss-hgesser-ulix.tex"
  __asm__ ("\
    .intel_syntax noprefix; \
    mov %0, eax; \
    mov %1, ebx; \
    mov %2, ecx; \
    mov %3, edx; \
    mov %4, esi; \
    mov %5, edi; \
    .att_syntax"
    :
    
    "=r"(thread_table[running[cpuid]].context[EAX]),   // eax
    "=r"(thread_table[running[cpuid]].context[EBX]),   // ebx
    "=r"(thread_table[running[cpuid]].context[ECX]),   // ecx
    "=r"(thread_table[running[cpuid]].context[EDX]),   // edx
    "=r"(thread_table[running[cpuid]].context[ESI]),   // esi
    "=r"(thread_table[running[cpuid]].context[EDI])    // edi
  );

  // WHAT ABOUT stack and PC?


/*
asm( "move int thread_table[running[cpuid]].R[0], R0"
     "move int thread_table[running[cpuid]].R[1], R1"
     "move int thread_table[running[cpuid]].R[2], R2"
     "move int thread_table[running[cpuid]].R[3], R3"
     "move int thread_table[running[cpuid]].R[4], R4"
     "move int thread_table[running[cpuid]].R[5], R5"
     "move int thread_table[running[cpuid]].R[6], R6"
     "move int thread_table[running[cpuid]].R[7], R7"
     "move int thread_table[running[cpuid]].R[8], R8"
     "move int thread_table[running[cpuid]].R[9], R9"
     "move int thread_table[running[cpuid]].R[10], R10"
     "move int thread_table[running[cpuid]].R[11], R11"
     "move int thread_table[running[cpuid]].R[12], R12"
     "move int thread_table[running[cpuid]].R[13], R13"
     "move int thread_table[running[cpuid]].R[14], R14"
     "move int thread_table[running[cpuid]].R[15], R15"
     "move int thread_table[running[cpuid]].USP, USP" );
*/
#line 9751 "../diss-hgesser-ulix.tex"
/*
asm( "move int thread_table[running[cpuid]].PC, [SSP+8]" );
*/
#line 9642 "../diss-hgesser-ulix.tex"
  add_to_ready_queue(running[cpuid]);
}

#line 9713 "../diss-hgesser-ulix.tex"
void yield_interrupt_handler() {
  resign(0);     /* check argument: CPU id  **hge** */
  assign(0);
  /*  asm( "RTI" );  */
}

#line 9767 "../diss-hgesser-ulix.tex"
void assign(int cpuid) {
  running[cpuid] = schedule(); // invoke the scheduler
  
#line 9779 "../diss-hgesser-ulix.tex"
  __asm__ ("\
    .intel_syntax noprefix; \
    mov eax, %0; \
    mov ebx, %1; \
    mov ecx, %2; \
    mov edx, %3; \
    mov esi, %4; \
    mov edi, %5; \
    .att_syntax"
    :: 
    
    "r"(thread_table[running[cpuid]].context[EAX]),   // eax
    "r"(thread_table[running[cpuid]].context[EBX]),   // ebx
    "r"(thread_table[running[cpuid]].context[ECX]),   // ecx
    "r"(thread_table[running[cpuid]].context[EDX]),   // edx
    "r"(thread_table[running[cpuid]].context[ESI]),   // esi
    "r"(thread_table[running[cpuid]].context[EDI])    // edi
  );
  
  // WHAT ABOUT stack and PC?
  
  // update TSS (new stack) 

/*

asm( "move int R0, thread_table[running[cpuid]].R[0]"
     "move int R1, thread_table[running[cpuid]].R[1]"
     "move int R2, thread_table[running[cpuid]].R[2]"
     "move int R3, thread_table[running[cpuid]].R[3]"
     "move int R4, thread_table[running[cpuid]].R[4]"
     "move int R5, thread_table[running[cpuid]].R[5]"
     "move int R6, thread_table[running[cpuid]].R[6]"
     "move int R7, thread_table[running[cpuid]].R[7]"
     "move int R8, thread_table[running[cpuid]].R[8]"
     "move int R9, thread_table[running[cpuid]].R[9]"
     "move int R10, thread_table[running[cpuid]].R[10]"
     "move int R11, thread_table[running[cpuid]].R[11]"
     "move int R12, thread_table[running[cpuid]].R[12]"
     "move int R13, thread_table[running[cpuid]].R[13]"
     "move int R14, thread_table[running[cpuid]].R[14]"
     "move int R15, thread_table[running[cpuid]].R[15]"

     "move int USP, thread_table[running[cpuid]].USP"
     "move int [SSP-8], thread_table[running[cpuid]].PC" );
*/
#line 9770 "../diss-hgesser-ulix.tex"
}

#line 9844 "../diss-hgesser-ulix.tex"
void block(int cpuid, blocked_queue* q) {
  
#line 9654 "../diss-hgesser-ulix.tex"
  __asm__ ("\
    .intel_syntax noprefix; \
    mov %0, eax; \
    mov %1, ebx; \
    mov %2, ecx; \
    mov %3, edx; \
    mov %4, esi; \
    mov %5, edi; \
    .att_syntax"
    :
    
    "=r"(thread_table[running[cpuid]].context[EAX]),   // eax
    "=r"(thread_table[running[cpuid]].context[EBX]),   // ebx
    "=r"(thread_table[running[cpuid]].context[ECX]),   // ecx
    "=r"(thread_table[running[cpuid]].context[EDX]),   // edx
    "=r"(thread_table[running[cpuid]].context[ESI]),   // esi
    "=r"(thread_table[running[cpuid]].context[EDI])    // edi
  );

  // WHAT ABOUT stack and PC?


/*
asm( "move int thread_table[running[cpuid]].R[0], R0"
     "move int thread_table[running[cpuid]].R[1], R1"
     "move int thread_table[running[cpuid]].R[2], R2"
     "move int thread_table[running[cpuid]].R[3], R3"
     "move int thread_table[running[cpuid]].R[4], R4"
     "move int thread_table[running[cpuid]].R[5], R5"
     "move int thread_table[running[cpuid]].R[6], R6"
     "move int thread_table[running[cpuid]].R[7], R7"
     "move int thread_table[running[cpuid]].R[8], R8"
     "move int thread_table[running[cpuid]].R[9], R9"
     "move int thread_table[running[cpuid]].R[10], R10"
     "move int thread_table[running[cpuid]].R[11], R11"
     "move int thread_table[running[cpuid]].R[12], R12"
     "move int thread_table[running[cpuid]].R[13], R13"
     "move int thread_table[running[cpuid]].R[14], R14"
     "move int thread_table[running[cpuid]].R[15], R15"
     "move int thread_table[running[cpuid]].USP, USP" );
*/
#line 9751 "../diss-hgesser-ulix.tex"
/*
asm( "move int thread_table[running[cpuid]].PC, [SSP+8]" );
*/
#line 9846 "../diss-hgesser-ulix.tex"
  add_to_blocked_queue(running[cpuid], q);
}

#line 9960 "../diss-hgesser-ulix.tex"
// Initialise our task state segment structure.
static void write_tss(int num, u16int ss0, uint esp0)
{
   // Firstly, let's compute the base and limit of our entry into the GDT.
   uint base = (uint) &tss_entry;
   uint limit = base + sizeof(tss_entry);

   // Now, add our TSS descriptor's address to the GDT.
   gdt_set_gate(num, base, limit, 0xE9, 0x00);

   // Ensure the descriptor is initially zero.
   memset(&tss_entry, 0, sizeof(tss_entry));

   tss_entry.ss0  = ss0;  // Set the kernel stack segment.
   tss_entry.esp0 = esp0; // Set the kernel stack pointer.

   // Here we set the cs, ss, ds, es, fs and gs entries in the TSS. These specify what
   // segments should be loaded when the processor switches to kernel mode. Therefore
   // they are just our normal kernel code/data segments - 0x08 and 0x10 respectively,
   // but with the last two bits set, making 0x0b and 0x13. The setting of these bits
   // sets the RPL (requested privilege level) to 3, meaning that this TSS can be used
   // to switch to kernel mode from ring 3.
   tss_entry.cs   = 0x0b;
   tss_entry.ss = tss_entry.ds = tss_entry.es = tss_entry.fs = tss_entry.gs = 0x13;
} 
#line 10371 "../diss-hgesser-ulix.tex"
void run_first_process () {
  kputs ("Address of testprocess_func: ");
  printhex ((uint)&testprocess_func); kputch ('\n');
  // switch_to_user_mode();

  // reserve kernel stack (old code)
  char *kstack;
  kstack = (char*) request_new_page (0);
    
  tss_entry.esp0 = (uint)kstack+KERNEL_STACK_SIZE;
 
  tss_flush();

  // cpu_usermode ((uint)&testprocess_func);
  // cpu_usermode ((uint)&simple_shell);
  
  printf ("TEST\n");
};
#line 10420 "../diss-hgesser-ulix.tex"
void init_process () {
  // can use labels and jmp, because jmp is relative, not absolute
  asm (".intel_syntax noprefix; \
; \
; \
; \
; \
    null:; \
    call dofork; \
    call dofork; \
    call dofork; \
    call dofork; \
; \
; \
; \
    mov eax, 20; \
    int 0x80; \
    mov ebx, 0x500; \
    mov [ebx], eax; \
    loop:; \
    call doshowpid; \
    jmp loop; \
    dofork:; \
    mov eax,2; \
    int 0x80; \
    ret; \
    doshowpid:; \
    mov eax, 20; \
    int 0x80; \
    mov eax,0x500; \
    mov ebx,[eax]; \
    add ebx,'a'-1; \
    mov eax,0x1001; \
    int 0x80; \
    ret; \
    .att_syntax; ");
};


void init_processy () {
  // can use labels and jmp, because jmp is relative, not absolute
  asm (".intel_syntax noprefix; \
    mov eax, 2; \
    int 0x80; \
    mov eax, 5; \
    mov ebx, 0; \
    int 0x80; \
    mov eax, 3; \
    mov ebx, 10; \
    int 0x80; \
    loopx:; \
    jmp loopx; \
    ret; \
    .att_syntax; ");
};

/*
void init_processy () {
  // can use labels and jmp, because jmp is relative, not absolute
  asm (".intel_syntax noprefix; \
    mov eax, 2; \
    int 0x80; \
    mov eax, 5; \
    mov ebx, 0; \
    int 0x80; \
    mov eax, 3; \
    mov ebx, 10; \
    int 0x80; \
    loopx: \
    jmp loopx; \
    ret; \
    .att_syntax");
};
*/
#line 10501 "../diss-hgesser-ulix.tex"
void create_init_process() {
  int tid = 1;                                // init process has pid 1
  int as = create_new_address_space(64*1024);    // should be bigger...
#line 10513 "../diss-hgesser-ulix.tex"
  int tcbid = register_new_tcb (as);
  thread_table[tcbid].tid = tid;
  // thread_table[tcbid].eip = 0;                // start at 0
  
  // tcbid is number of used TCB
  activate_address_space (as);
  memcpy (0, (void*)&init_process, 200); 
  
  char* kstack = (char*)request_new_page(0);
  uint adr = (uint)kstack;                     // one page for kernel stack
  tss_entry.esp0 = adr+KERNEL_STACK_SIZE;
  tss_entry.esp = 32*1024;
  thread_table[tcbid].kstack = kstack;
  current_task = tid;                         // current_task is global!  
  
  add_to_ready_queue (tcbid);
  ENABLE_SCHEDULER;
  cpu_usermode (0, 32*1024);
};
#line 10545 "../diss-hgesser-ulix.tex"
int find_free_TCB_entry () {
  int new_tid = 0;   // start with 1
  int i;
  for (i = 1; i < 1024; i++) {
    if (thread_table[i].tid > new_tid)
      new_tid = thread_table[i].tid;
  }
  new_tid++;  // +1

  if (new_tid==1024) {
    printf ("ERROR: no free thread id\n");
    return -1;
  }
  return new_tid;
}
#line 10563 "../diss-hgesser-ulix.tex"
#define PROGSIZE 32768
int start_program_from_disk (char *progname) {
  // secno: program is located in this sector
  unsigned char buf[PROGSIZE];
  
  // newer code: launch sh from MINIX floppy
  int mfd = mx_open (progname, O_RDONLY);
  mx_read (mfd, (char*)&buf, PROGSIZE);
  mx_close (mfd);
  
  // new code: launch sh from floppy
  /*
  int fd = simplefs_open ("sh");
  simplefs_read (fd, (char*)&buf, PROGSIZE);
  simplefs_close (fd);
  */
  
  // address space
  int as = create_new_address_space(64*1024);
  int tid = register_new_tcb (as);
  thread_table[tid].tid = tid;
  thread_table[tid].ppid = 0;
  thread_table[tid].new = false;  // not freshly created via fork()
  
  thread_table[tid].terminal = 0;  // default terminal: 0

  memcpy (&thread_table[tid].cmdline, "new", CMDLINE_LENGTH);

  // copy program to process memory
  activate_address_space (as);
  memcpy (0, &buf, PROGSIZE);   // process memory starts at 0.

  // kernel stack:

  // OLD VERSION
  /*
  page_table* stackpgtable = (page_table*)request_new_page(0);
    // this must be removed when the process terminates!!!!!!!!!
  memset (stackpgtable, 0, sizeof(page_table));
  KMAPD ( &current_pd->ptds[767], mmu (0, (uint)stackpgtable) );
  uint frameno = request_new_frame ();
  as_map_page_to_frame (current_as, 0xbffff, frameno);
  char* kstack = (char*)0xbffff000;
  uint adr = (uint)kstack;                     // one page for kernel stack
  tss_entry.esp0 = adr+KERNEL_STACK_SIZE;
  tss_entry.esp = 64*1024;
  thread_table[tid].kstack = kstack;
  */
  
  
  // reserve kernel stack (new code, more than 1 page)
  
  uint framenos[KERNEL_STACK_PAGES];   // frame numbers of kernel stack pages
  int i; for (i=0; i<KERNEL_STACK_PAGES; i++)
    framenos[i] = request_new_frame();
  page_table* stackpgtable = (page_table*)request_new_page(0);
  // this must be removed when the process terminates!!!!!!!!!
  memset (stackpgtable, 0, sizeof(page_table));
  KMAPD ( &current_pd->ptds[767], mmu (0, (uint)stackpgtable) );
  for (i=0; i<KERNEL_STACK_PAGES; i++)
    as_map_page_to_frame (current_as, 0xbffff - i, framenos[i]);
  char* kstack = (char*) (0xc0000000-KERNEL_STACK_SIZE);
  uint adr = (uint)kstack;                     // one page for kernel stack
  tss_entry.esp0 = adr+KERNEL_STACK_SIZE;
  tss_entry.esp = 64*1024;
  thread_table[tid].kstack = kstack;  

  
  
  debug_printf ("DEBUG. start_from_disk, kstack   = 0x%x\n", adr);
  debug_printf ("DEBUG. start_from_disk, tss.esp0 = 0x%x\n", tss_entry.esp0);
  
  /** 2012/11/29 **/
  thread_table[tid].esp0 = (uint)kstack + KERNEL_STACK_SIZE;
  thread_table[tid].ebp = (uint)kstack + KERNEL_STACK_SIZE;
  
  
  // set current directory
  memcpy (thread_table[tid].cwd, "/", 2);

  current_task = tid;                         // current_task is global!  
  
  add_to_ready_queue (tid);
  thread_table[tid].state = TSTATE_READY;
  
  // ENABLE_SCHEDULER;
  
  return 0;   // WARNING, WE JUMP TO USERMODE ELSEWHERE
  
  
  if (tid == 1) {
    // first thread; jump to usermode
    cpu_usermode (0, 64*1024);
  }
};
#line 10702 "../diss-hgesser-ulix.tex"
void print_thread_table() {
  int i;
  printf ("Thread IDs: ");
  for (i=0; i<1024; i++) {
    if (thread_table[i].used) {
      printf ("%d, ", thread_table[i].tid);
    }
  };
  printf ("\n");
}
#line 10746 "../diss-hgesser-ulix.tex"
void inline copy_frame (int out, int in) {
  uint outaddr = out << 12;
  uint inaddr  = in  << 12;
  // printf ("DEBUG: phys.frame.copy 0x%05x <- 0x%05x\n", out, in);
  memcpy ((void*)PHYSICAL(outaddr),(void*)PHYSICAL(inaddr),PAGE_SIZE);
};
#line 10758 "../diss-hgesser-ulix.tex"
int ulix_fork (struct regs_syscall *r) {
  TCB *t_old; TCB *t_new;
  struct regs rr;
  int i;
  int tid, new_tid;

  asm ("cli");

  INSIDE_FORK = true;
  
  debug_printf ("ULIX fork\n");
  
  int as = current_as;  tid = current_task;  int ppid = tid;
  int new_as = create_new_address_space (0);  // clones kernel part of page dir.
  new_tid = register_new_tcb (new_as);

  t_old = &thread_table[tid];
  t_new = &thread_table[new_tid];
  
  *t_new = *t_old;   // copy the TCB
    // get rid of the copying; some data were already setup in register_new_tcb()
  t_new->state = TSTATE_FORK;
  t_new->tid = new_tid;
  t_new->ppid = tid;    // parent process
  t_new->addr_space = new_as;

  // copy registers to new thread
  rr = *(struct regs*)r;
  rr.ebx = 0;  // for child: return value is 0
  t_new->regs = rr;
  
  asm ("mov %%esp, %0" : "=r"(t_new->esp0));  

  // copy the memory
  address_spaces[new_as].memstart = address_spaces[as].memstart;
  address_spaces[new_as].memend   = address_spaces[as].memend;
    // create_new_address_space() also creates a new page directory

  
#line 10840 "../diss-hgesser-ulix.tex"
  // create new kernel stack and copy the old one

  page_table* stackpgtable = (page_table*)request_new_page(0);
  // this must be removed when the process terminates!!!!!!!!!
  memset (stackpgtable, 0, sizeof(page_table));
  page_directory *tmp_pd;
  tmp_pd = address_spaces[new_as].pd;
  KMAPD ( &tmp_pd->ptds[767], mmu (0, (uint)stackpgtable) );
  
  uint framenos[KERNEL_STACK_PAGES];   // frame numbers of kernel stack pages
  for (i=0; i<KERNEL_STACK_PAGES; i++)
    framenos[i] = request_new_frame();
    
  // debug_printf ("fork: new kernel stack at frame %x\n", frameno);

  // as_map_page_to_frame (new_as, 0xbffff, frameno);

  for (i=0; i<KERNEL_STACK_PAGES; i++)
    as_map_page_to_frame (new_as, 0xbffff - i, framenos[i]);

  // char* kstack = (char*)0xbffff000;
  char* kstack = (char*) (0xc0000000-KERNEL_STACK_SIZE);

  thread_table[tid].kstack = kstack;
  
  t_new->kstack = t_old->kstack;
  
  debug_printf ("ulix_fork: memcpy(%x,%x,%x)\n",
           (void*)PHYSICAL(mmu(new_as, 0xbffff000)),
           (void*)PHYSICAL(mmu(as, 0xbffff000)),
           KERNEL_STACK_SIZE );
  // assert ( mmu(as, 0xbffff000) != -1 );
  if ( mmu(as, 0xbffff000) == -1 ) {
    printf ("MMU ERROR. as=%d\n", as);
  };
  
  // copy each page separately: they need not be physically connected or in order
  for (i=0; i<KERNEL_STACK_PAGES; i++)
    memcpy ( (void*)PHYSICAL(mmu(new_as, 0xc0000000-KERNEL_STACK_SIZE + i*PAGE_SIZE)),
             (void*)PHYSICAL(mmu(as,     0xc0000000-KERNEL_STACK_SIZE + i*PAGE_SIZE)),
             PAGE_SIZE );
  debug_printf ("ulix_fork: memcpy done\n");
#line 10797 "../diss-hgesser-ulix.tex"
  
#line 10889 "../diss-hgesser-ulix.tex"
  // clone first 3 GB (minus last directory entry) of address space
  page_directory *pd;  page_directory *new_pd;
  page_table *pt;      page_table *new_pt;
  pd     = address_spaces[as].pd;
  new_pd = address_spaces[new_as].pd;
  int j, frameid;
  for (i = 0; i<767; i++) {     // only 0..766, not 0..767
    if (pd->ptds[i].present) {
      // copy page table descriptor
      memcpy (&(new_pd->ptds[i]), &(pd->ptds[i]), sizeof(page_table_desc));
      frameid = request_new_frame();  // reserve new frame
      new_pd->ptds[i].frame_addr = frameid;
      // walk through the entries of the page table
      pt = (page_table*)PHYSICAL(pd->ptds[i].frame_addr << 12);
      new_pt = (page_table*)PHYSICAL(frameid << 12);
      memset (new_pt,0,4);  // clear descriptor
      for (j=0; j<1024; j++) {
        if (pt->pds[j].present) {
          // copy physical frames
          frameid = request_new_frame();

          debug_printf ("ulix_fork: memcpy begin, frameid=%d, pt->pds[j].frame_addr=%d, (i,j)=(%d,%d)\n",
            frameid, pt->pds[j].frame_addr, i, j);
          copy_frame (frameid, pt->pds[j].frame_addr);
          debug_printf ("ulix_fork: memcpy done\n");
          
          new_pt->pds[j].frame_addr = frameid;
          new_pt->pds[j].present = true;
          new_pt->pds[j].writeable = true;
          new_pt->pds[j].user_accessible = true;
        };
      };
    };
  };
#line 10798 "../diss-hgesser-ulix.tex"
  
#line 10929 "../diss-hgesser-ulix.tex"
int reg_esp0;
__asm__ __volatile__("mov %%esp, %0": "=r"(reg_esp0));
// printf ("Reg. ESP0: 0x%08x\n", reg_esp0);

uint testa1, testa2;
unsigned char c1, c2;
// printf ("DEBUG: compare as -- Ungleiche Inhalte in: \n");

int count = 0;
for (i = 0; i<8192; i++) {
  // if (count>10) break;
  testa1 = mmu(as, i);
  testa2 = mmu(new_as, i);
  c1 = PEEKPH (testa1);
  c2 = PEEKPH (testa2);
  if (c1 != c2) {
    printf ("<compare address space>: 0x%08x: 0x%08x = %02x, 0x%08x = %02x \n", 
      i, testa1, c1, testa2, c2);
    count++;
  };
};
// printf ("count = %d\n",count);
#line 10799 "../diss-hgesser-ulix.tex"
  
  // mark new thread as ready and new
  t_new->state = TSTATE_READY;
  t_new->new = true;
  
  debug_printf ("ULIX new_fork, return\n");
  

  uint eip = get_eip();
  
  debug_printf ("AFTER GET_EIP: current_task = %d, ppid = %d\n", current_task, ppid); 
  asm ("mov %%ebp,%0" : "=r"(tmp_ebp)); 
  debug_printf ("EBP = %x\n", tmp_ebp);
  debug_printf ("&ppid = %x\n", &ppid);

  if (current_task == ppid) {
    uint esp; asm volatile("mov %%esp, %0" : "=r"(esp));
    uint ebp; asm volatile("mov %%ebp, %0" : "=r"(ebp));
    thread_table[new_tid].ebp = ebp;
    thread_table[new_tid].eip = eip;
    thread_table[new_tid].esp0 = esp;
    debug_printf ("DEBUG: Writing eip  = %x to thread table\n", eip);
    debug_printf ("DEBUG: Writing esp0 = %x to thread table\n", esp);
    debug_printf ("DEBUG: Writing ebp  = %x to thread table\n", ebp);
    
    add_to_ready_queue (new_tid);

    debug_printf ("fork going to return %d\n", new_tid);
    asm ("sti");
    INSIDE_FORK = false;
    return new_tid;
  } else {
    debug_printf ("fork going to return 0 \n");
    asm ("sti");
    INSIDE_FORK = false;
    return 0;
  }
} 
#line 11627 "../diss-hgesser-ulix.tex"
void kl_P(kl_semaphore_id sid) {
  struct kl_semaphore sem = 
#line 11705 "../diss-hgesser-ulix.tex"
kl_semaphore_table[sid]

#line 11628 "../diss-hgesser-ulix.tex"
                                                                           ;
  sem.counter = sem.counter - 1;
  if (sem.counter < 0) {
    block(0, &sem.bq);
    assign(0);
  }
}

#line 11642 "../diss-hgesser-ulix.tex"
void kl_V(kl_semaphore_id sid) {
  struct kl_semaphore sem = 
#line 11705 "../diss-hgesser-ulix.tex"
kl_semaphore_table[sid]

#line 11643 "../diss-hgesser-ulix.tex"
                                                                           ;
  if (sem.counter < 0) {
    // ERROR IN NEXT LINE. WHAT'S HAPPENING HERE?
    // ->  bq -> sem.bq ?
    //! deblock(front_of_blocked_queue(bq), &bq);
  }
  sem.counter = sem.counter + 1;
}

#line 11722 "../diss-hgesser-ulix.tex"
kl_semaphore_id new_kl_semaphore(int k) {
  int check = MAX_SEMAPHORES;
  while (kl_semaphore_table[next_kl_semaphore].used == true) {
    next_kl_semaphore = (next_kl_semaphore + 1) % MAX_SEMAPHORES;
    check = check - 1;
    if (check <= 0) {
      return -1;
    }
  }
  kl_semaphore_table[next_kl_semaphore].used = true;
  kl_semaphore_table[next_kl_semaphore].counter = k;
  initialize_blocked_queue(&kl_semaphore_table[next_kl_semaphore].bq);
  return next_kl_semaphore;
}

#line 11743 "../diss-hgesser-ulix.tex"
void release_kl_semaphore(kl_semaphore_id s) {
  kl_semaphore_table[s].used = false;
  while (front_of_blocked_queue(kl_semaphore_table[s].bq) != 0) {
    thread_id t = front_of_blocked_queue(kl_semaphore_table[s].bq);
    // ERROR IN NEXT LINE
    //! remove_from_blocked_queue(t, kl_semaphore_table[s].bq]);
    add_to_ready_queue(t);
  }
}
#line 11936 "../diss-hgesser-ulix.tex"
int tsl_test_and_set (lock lockvar) {
  short int res;
  res = __sync_lock_test_and_set (&(lockvar->l), 1);
  return res;
}

void tsl_reset (lock lockvar) {
  __sync_lock_release (&(lockvar->l));
  return;
}

void LOCK (lock lockvar) {
  if (current_task == 0) return;  // no process!
  debug_printf ("ENTER LOCK()\n");
  int count=0;
  while ( tsl_test_and_set (lockvar) != 0 ) {
  
  
  
    debug_printf ("GOING TO CALL add_to_blocked_queue; count=%d\n", count++);
    if (count==0) {
      // put process to sleep
      remove_from_ready_queue (current_task);
      add_to_blocked_queue (current_task, &(lockvar->bq));
      thread_table[current_task].state = TSTATE_LOCKED;
      printf ("DEBUG: add thread %d to bq %x\n", current_task, &(lockvar->bq));
      printf ("DEBUG: bq: ");
      blocked_queue bq = lockvar->bq;
      int tid = bq.next;
      for (;;) {
        printf ("%d ", tid);
        if (tid == 0) 
          break;
        else if (thread_table[tid].next == tid)
          break;
        else
          tid = thread_table[tid].next;
      }
      printf ("\n");
    }

    // calling yield (via syscall 66)
    debug_printf ("LOCK going to call yield()\n");
    asm (".intel_syntax noprefix; \
      sti;; \
      mov eax, 66;; \
      int 0x80;; \
      .att_syntax; ");
  }
  return;
}

void UNLOCK (lock lockvar) {
  if (current_task == 0) return;  // no process!
  debug_printf ("UNLOCK\n");
  tsl_reset (lockvar);
  // wake a process
  blocked_queue bq = lockvar->bq;
  thread_id head = bq.next;
  if (head != 0) {
    remove_from_blocked_queue (head, &bq);
    add_to_ready_queue (head);
    thread_table[head].state = TSTATE_READY;
    printf ("DEBUG: remove thread %d from bq\n", head);
    
    // If one thread is waiting, yield!
    // TODO: THIS DOES NOT HELP, CHECK IT...
    // calling yield (via syscall 66)
    debug_printf ("UNLOCK going to call yield()\n");
    asm (".intel_syntax noprefix; \
      sti; ; \
      mov eax, 66;; \
      int 0x80;; \
      .att_syntax; ");
  }
}

lock get_new_lock () {
  int i;
  LOCK (kernel_locks);  // lock the list of kernel locks, we use kernel_locks[0]
  for (i=1; i<100; i++) {
    if (!kernel_locks[i].used) {
      kernel_locks[i].used = true;
      kernel_locks[i].bq.next = kernel_locks[i].bq.prev = 0;
      UNLOCK (kernel_locks);  // unlock access to the list
      return &kernel_locks[i];
    }
  }
  return NULL;
}
#line 12308 "../diss-hgesser-ulix.tex"
void scheduler (struct regs *r, int source) {
  debug_printf ("*");
  inside_yield = false;   // reset inside_yield value
                          // it may have been set from syscall_yield
  
  
#line 12492 "../diss-hgesser-ulix.tex"
{
  int pid, ppid;
  for (pid=0; pid < MAX_THREADS; pid++) {
    if (thread_table[pid].state == TSTATE_ZOMBIE) {
      ppid = thread_table[pid].ppid;
      if ( (thread_table[ppid].state == TSTATE_WAITFOR) &&
           (thread_table[ppid].waitfor == pid) ) {
        debug_printf ("exit: remove_from_blocked_queue (%d,%x)\n", ppid, &waitpid_queue);
        remove_from_blocked_queue (ppid, &waitpid_queue);
        add_to_ready_queue (ppid);
        thread_table[ppid].state = TSTATE_READY;   // mark parent as ready
        thread_table[pid].state = TSTATE_EXIT;
        // thread_table[pid].used = false;
      }
    }
  }
}
#line 12313 "../diss-hgesser-ulix.tex"
                            // deal with zombies if we have any
  
  // check if we want to run the scheduler
  if (!scheduler_is_active)  return;
  if (!thread_table[2].used) return;    // are there already two threads?

  int tid = current_task; t_old = &thread_table[tid];
    
  
#line 12337 "../diss-hgesser-ulix.tex"
search:
if (source == SCHED_SRC_WAITFOR) {
  // we cannot use the ->next pointer!
  debug_printf ("scheduler called from syscall_waitpid(). tid(old) = %d, ", tid);    
  tid = thread_table[1].next;   // ignore idle process
  debug_printf ("tid(new) = %d\n", tid);
} else {
  tid = t_old->next;
}
if (tid==0)  // end of queue reached
  tid = thread_table[1].next;   // ignore idle process
if (tid==0)  // still 0? run idle task
  tid = 1; // idle
t_new = &thread_table[tid];
if (t_new->addr_space == 0)       goto search;
if (t_new->state != TSTATE_READY) goto search;
#line 12322 "../diss-hgesser-ulix.tex"
  
  if (t_new != t_old) {
    // debug_printf ("Going to context switch from process %d to %d\n", 
    //               t_old->tid, t_new->tid);
    current_task = tid;
    
#line 12410 "../diss-hgesser-ulix.tex"
// Store current
t_old->regs = *r;         // save registers in thread table
COPY_ESP_TO_VAR (t_old->esp0);  // current esp (kernel)
COPY_EBP_TO_VAR (t_old->ebp);   // current ebp

// activate_address_space t_new->addr_space
uint mem  = mmu(0, (uint)address_spaces[t_new->addr_space].pd);
WRITE_CR3 (mem);
current_as = t_new->addr_space;
current_pd = address_spaces[t_new->addr_space].pd;

// Restore new
COPY_VAR_TO_ESP (t_new->esp0);
COPY_VAR_TO_EBP (t_new->ebp); 
*r = t_new->regs;

if (FROM_KERNEL_MODE) {
  debug_printf ("NOTICE: scheduler was called from kernel mode. Prepare for crash :/ \n");
};

if (t_new->new) {
  
#line 12445 "../diss-hgesser-ulix.tex"
  debug_printf ("This process is new!\n");
  debug_printf ("current_task = %d\n", current_task);
  thread_table[current_task].new = false;
  asm ("push %0" : : "r"(thread_table[current_task].eip));
  // asm ("cli");
  asm ("ret");
#line 12432 "../diss-hgesser-ulix.tex"
}
#line 12328 "../diss-hgesser-ulix.tex"
  }
  return;
}
#line 13322 "../diss-hgesser-ulix.tex"
// define DEBUG_BUFFER
void readblock (int blockno, char* buffer) {
  char extrabuf[1024]; int errors = 0;
  debug_printf ("readblock: arg1 address: %x\n", &blockno);
  debug_printf ("readblock: arg2 address: %x\n", &buffer);
  debug_printf ("readblock(%d): entered\n", blockno);
  
  // check if data were in the buffer cache
  if (buffer_read (0, blockno, buffer) == 0) {
    #ifdef DEBUG_BUFFER
    // let's debug
    fdc_read_sector (1, blockno*2,     extrabuf);
    fdc_read_sector (1, blockno*2 + 1, extrabuf + 512);
    for (int i=0; i<1024; i++) {
      if (buffer[i] != extrabuf[i]) {
        errors++;
        if (errors==1) printf ("BUFFER: readblock(%d) differs: ", blockno);
        debug_printf ("%d,", i);
      }
    }
    if (errors > 0) printf (" -- %d errors.\n", errors);
    #endif
    
    return;
  }
  
  fdc_read_sector (1, blockno*2,     buffer);
  fdc_read_sector (1, blockno*2 + 1, buffer + 512);
  
  // update buffer cache
  buffer_write (0, blockno, buffer);
};

int fdc_write_sector(int device, int block, char* buffer);

void writeblock (int blockno, char* buffer) {
  fdc_write_sector (1, blockno*2,     buffer);
  fdc_write_sector (1, blockno*2 + 1, buffer + 512);

  // update buffer cache (if it is in the cache)
  if ( buffer_contains (0, blockno) )
    buffer_write (0, blockno, buffer);
};


#line 13373 "../diss-hgesser-ulix.tex"
typedef unsigned char uchar;

void show_superblock() {
  // Aufgabe b)
  uchar block[1024];
  struct minix_superblock* sblock;
  readblock (1, (uchar*)block);    // Superblock = Block 1
  sblock = (struct minix_superblock*) &block;
  printf ("s_ninodes:       %d\n", sblock->s_ninodes);
  printf ("s_nzones:        %d\n", sblock->s_nzones); 
  printf ("s_imap_blocks:   %d\n", sblock->s_imap_blocks); 
  printf ("s_zmap_blocks:   %d\n", sblock->s_zmap_blocks); 
  printf ("s_firstdatazone: %d\n", sblock->s_firstdatazone); 
  printf ("s_log_zone_size: %d\n", sblock->s_log_zone_size); 
  printf ("s_max_size:      %d\n", sblock->s_max_size); 
  printf ("s_magic:         %d\n", sblock->s_magic); 
  printf ("s_state:         %d\n", sblock->s_state); 
  printf ("s_zones:%d\n", sblock->s_zones);
}
#line 13398 "../diss-hgesser-ulix.tex"
unsigned int get_imap_bit (int i) {
  debug_printf ("get_imap_bit: entered\n");

  /*  
  uint reg_esp0;
  __asm__ __volatile__("mov %%esp, %0": "=r"(reg_esp0));
  printf ("get_imap_bit, Reg. ESP0: 0x%08x\n", reg_esp0);
  */
  
  // Aufgabe d)
  uchar block[1024];
  unsigned int byte;
  debug_printf ("get_imap_bit: before readblock()\n");
  readblock (2, (uchar*)&block);    // Inode-Map = Block 2
  debug_printf ("get_imap_bit: after readblock()\n");
    // vollstaendige Loesung: evtl. mehr als 1 Block bearbeiten
  byte = block[i/8];
  return (byte >> (i%8)) % 2;  
};

unsigned int get_zmap_bit (int i) {
  // Aufgabe d)
  uchar block[1024];
  unsigned int byte;
  readblock (3, (uchar*)&block);    // Zone-Map = Block 3
    // vollstaendige Loesung: evtl. mehr als 1 Block bearbeiten
  byte = block[i/8];
  return (byte >> (i%8)) % 2;  
};
#line 13439 "../diss-hgesser-ulix.tex"
void set_clear_imap_bit (int i, int value) {
  // Aufgabe d), eine Funktion fuer set und clear
  uchar block[1024];
  unsigned int byte;
  readblock (2, (uchar*)&block);    // Inode-Map = Block 2
    // vollstaendige Loesung: evtl. mehr als 1 Block bearbeiten
  byte = block[i/8];
  if (value==0) {
    // Clear bit
    byte = byte & (255 - (1<<(i%8)));
  } else {
    // Set bit
    byte = byte | 1<<(i%8);
  }; 
  block[i/8] = byte;
  writeblock (2, (uchar*)&block);  
};

void set_clear_zmap_bit (int i, int value) {
  // Aufgabe d), eine Funktion fuer set und clear
  uchar block[1024];
  unsigned int byte;
  readblock (3, (uchar*)&block);    // Zone-Map = Block 3
    // vollstaendige Loesung: evtl. mehr als 1 Block bearbeiten
  byte = block[i/8];
  if (value==0) {
    // Clear bit
    byte = byte & (255 - (1<<(i%8)));
  } else {
    // Set bit
    byte = byte | 1<<(i%8);
  }; 
  block[i/8] = byte;
  writeblock (3, (uchar*)&block);  
};

void set_imap_bit (int i)   { set_clear_imap_bit (i, 1); };
void clear_imap_bit (int i) { set_clear_imap_bit (i, 0); };
void set_zmap_bit (int i)   { set_clear_zmap_bit (i, 1); };
void clear_zmap_bit (int i) { set_clear_zmap_bit (i, 0); };
#line 13486 "../diss-hgesser-ulix.tex"
int request_inode () {
  // Aufgabe e)
  int no_inodes = 480;  // korrekte Loesung: S-Block auswerten
  int i;
  for (i = 0; i < no_inodes; i++) {
    if (get_imap_bit (i) == 0) {
      // Treffer!
      set_imap_bit (i);   // als belegt markieren
      return i;
    }
  }
  return -1; // nichts gefunden
};

int request_block () {
  // Aufgabe e)
  int no_zones = 1440;  // korrekte Loesung: S-Block auswerten
  int i;
  for (i = 0; i < no_zones; i++) {
    if (get_zmap_bit (i) == 0) {
      // Treffer!
      set_zmap_bit (i);   // als belegt markieren
      return i+33;        // Blocknr.: i+33 !!
    }
  }
  return -1; // nichts gefunden
};
#line 13598 "../diss-hgesser-ulix.tex"
int read_write_inode (int i, struct minix2_inode* inodeptr, int wr_flag) {
  debug_printf ("read_write_inode: entered\n");
  
  /*
  uint reg_esp0;
  __asm__ __volatile__("mov %%esp, %0": "=r"(reg_esp0));
  printf ("read_write_inode, Reg. ESP0: 0x%08x\n", reg_esp0);
  */
  
  // Aufgabe 13 a)
  // Funktion liest oder schreibt
  i--;  // erster Inode: Nr. 1, aber Position 0 in Tabelle
  if ((i<0) || (i > 479)) 
    return 0;  // korrekte Loesung wertet S-Block aus
  if (get_imap_bit(i+1) == 0) {
    printf ("DEBUG: get_imap_bit(%d) = %d in read_inode\n", i+1, get_imap_bit(i));
    return 0;  // unbelegter Inode
  }
  debug_printf ("read_write_inode: after get_imap_bit()\n");

  
  // Speicher fuer Inode schon reserviert
  const int inodesize = sizeof (struct minix2_inode);
  const int inodesperblock = BLOCK_SIZE / inodesize;
  
  int blockno, blockoffset;
  blockno = i / inodesperblock + 4;  // Tabelle ab Block 4
  blockoffset = i % inodesperblock;
  
  uchar block[1024];
  // Block muss auch bei write_inode() erst gelesen werden

  // printf ("DEBUG: read_inode; inodeno = %d, blockno = %d\n", i, blockno);
    

  readblock (blockno, (uchar*)&block);

  // Offset addieren, Vorsicht vor Pointer-Arithmetik!
  void* addr = (void*)&block;
  addr += blockoffset*inodesize;

  // lesen oder schreiben?
  if (!wr_flag) {
    memcpy (inodeptr, (uchar*)addr, inodesize);
  } else {
    memcpy ((uchar*)addr, inodeptr, inodesize);
    // ganzen Block ins Image zurueck schreiben
    writeblock (blockno, (uchar*)&block);
  };
  return (i+1);  // wieder Originalnummer...
};

int read_inode (int i, struct minix2_inode* inodeptr) {
  // printf ("DEBUG: read_inode %d\n", i);
  return read_write_inode (i, inodeptr, 0);  // 0 = false
}

int write_inode (int i, struct minix2_inode* inodeptr) {
  return read_write_inode (i, inodeptr, 1);  // 1 = true
}
#line 13671 "../diss-hgesser-ulix.tex"
void show_inode (struct minix2_inode* inode) {
  // Aufgabe 13 a)
  printf ("i_mode    : %o (oct)\n", inode->i_mode);
  printf ("i_nlinks  : %d\n", inode->i_nlinks);
  printf ("i_uid     : %d\n", inode->i_uid);
  printf ("i_gid     : %d\n", inode->i_gid);
  printf ("i_size    : %d\n", inode->i_size);
  printf ("i_atime   : %d\n", inode->i_atime);
  printf ("i_mtime   : %d\n", inode->i_mtime);
  printf ("i_ctime   : %d\n", inode->i_ctime);
  int i;
  for (i = 0; i<10; i++)
  printf ("i_zone[%d] : %d\n", i, inode->i_zone[i]);
};
#line 13701 "../diss-hgesser-ulix.tex"
int read_block_list  (int i, uint32_t* blocklist) {
  // Aufgabe 13 b)
  struct minix2_inode inode;
  if (!read_inode (i, &inode)) return -1;
  for (i = 0; i<10; i++) {
    *blocklist++ = inode.i_zone[i];
    if (inode.i_zone[i]==0) return i;
  };
  *blocklist = 0;
  return i;
};

int write_block_list (int i, uint32_t* blocklist) {
  // Aufgabe 13 b)
  struct minix2_inode inode;
  if (!read_inode (i, &inode)) return -1;
  for (i = 0; i<10; i++) {
    inode.i_zone[i] = *blocklist++;
    if (inode.i_zone[i]==0) return i;
  };
  *blocklist = 0;
  return i;
};
#line 13737 "../diss-hgesser-ulix.tex"
void create_null_file (int size, char* filename) {
  // Aufgabe 13 c)
  int nblocks, i;
  if (size == 0)
    nblocks = 0;
  else
    nblocks = (size-1)/BLOCK_SIZE+1;  // Rechnerei...
    
  if (nblocks>7) {
    // Fehler: nicht genug Eintraege in Liste
    printf ("Fehler: mehr als 7 direkte Blockadressen\n");
    //!exit(1);
  };
  
  uint32_t* blist = kmalloc ((nblocks+1)*sizeof(uint32_t));
  uint32_t* tmp = blist;  // Adresse merken
  for (i = 0; i<nblocks; i++)
    *blist++ = request_block ();
  *blist = 0;
  blist = tmp;
  int inodenr = request_inode ();
  write_block_list (inodenr, blist);
  // weitere Eintraege im Inode
  struct minix2_inode inode;
  read_inode (inodenr, &inode);
  for (i = 0; i<nblocks; i++)
    inode.i_zone[i] = *blist++;
  inode.i_size = size;
  inode.i_atime = inode.i_ctime = inode.i_mtime = 9999;
  inode.i_uid = inode.i_gid = 0;
  inode.i_nlinks = 0;  // setzen wir erst spaeter auf 1
  inode.i_mode = S_IFREG | 0664;
  write_inode (inodenr, &inode);
  // Datenblöcke mit Nullen füllen
  // for (i = 0; i<nblocks; i++)
  //   ...
  // Verzeichniseintrag anlegen
  write_link (inodenr, filename);
  blist = tmp;
  kfree (blist);
};
#line 13817 "../diss-hgesser-ulix.tex"
int read_write_dir_entry (int inodenr, int entrynr, 
  struct minix_dir_entry* entry, int wr_flag) {
  debug_printf ("read_write_dir_entry: entered\n");
  
  // unvollstaendige Loesung: nur 1 Block mit Eintraegen
  char block[1024];
  struct minix2_inode inode;
  debug_printf ("read_write_dir_entry: before read_inode()\n");
  read_inode (inodenr, &inode);  // Dir-Inode lesen
  debug_printf ("read_write_dir_entry: after read_inode()\n");
  int blockno;
  blockno = inode.i_zone[0];     // erster Block mit Eintraegen
  readblock (blockno, (uchar*)&block);
  
  int offset = 32*entrynr;       // jeder Eintrag 32 Bytes
  if (!wr_flag) {
    // lesen
    /*
    printf ("debug: &block        = %p\n", &block);
    printf ("debug: &block+offset = %p\n", ((char*)&block)+offset);
    printf ("debug: offset = %d\n", offset);
    */
    memcpy (entry, ((char*)&block)+offset, 32);
    if (entry->inode!=0)
      return 1; // true: hat Inhalt
    else
      return 0; // false: kein Inhalt
  } else {
    // schreiben
    memcpy (((uchar*)&block)+offset, entry, 32);
    writeblock (blockno, (uchar*)&block);
    return 1; // true
  };
};

int read_dir_entry (int inodenr, int entrynr, struct minix_dir_entry* entry) {
  read_write_dir_entry (inodenr, entrynr, entry, 0);  // 0 = false
};

int write_dir_entry (int inodenr, int entrynr, struct minix_dir_entry* entry) {
  read_write_dir_entry (inodenr, entrynr, entry, 1);  // 1 = true
};
#line 13952 "../diss-hgesser-ulix.tex"
void write_link (int inodenr, const char* path) {
  printf ("DEBUG: write_link (%d, %s) entered.\n", inodenr, path);
  struct minix_dir_entry dentry;
  struct minix2_inode inode;
  increase_link_count (inodenr);
  int i;
  char dirname[256];
  char filename[30];
  // Pruefen, ob es den Namen schon gibt
  if (file_exists (path)) {
      printf ("FEHLER: Name %s schon vorhanden!\n", path);
      return;
  };
    
  // search for directory to enter file
  strncpy (dirname, path, 256);
  int tmp = strlen(dirname)-1;
  for (;;) {
    if (dirname[tmp] == '/') {
      dirname[tmp] = 0;   // truncate path at last slash
      break;
    }
    tmp--;
    if (tmp < 0) {
      printf ("ERROR: no directory in path %s\n", path);
      return;   // error: found no /
    }
  }
  strncpy (filename, path+tmp+1, 30);
  
  if (dirname[0] == 0) {
    dirname[0] = '/'; dirname[1] = 0;
  }
  
  int dir_inode_no = pathname_to_ino (dirname);
  
  printf ("DEBUG: dirname='%s' (ino: %d), filename='%s'\n", dirname, dir_inode_no, filename);

  // Freien Platz suchen und eintragen
  for (i=0; i<32; i++) {
    read_dir_entry (dir_inode_no, i, &dentry);   // 1: Inode von /
    if (dentry.inode==0) {
      // leerer Eintrag gefunden
      dentry.inode = inodenr;
      memcpy ((char*)dentry.name, filename, 30);
      write_dir_entry (dir_inode_no, i, &dentry);
      
      // Groesse anpassen
      read_inode (dir_inode_no, &inode);
      // printf ("debug: inode.i_size = %d\n", inode.i_size);
      if (inode.i_size < 32*(i+1)) {
        inode.i_size = 32*(i+1);
        write_inode (dir_inode_no, &inode);
      };
      return;
    };
  };
  // nichts gefunden?
  printf ("FEHLER: kein freier Eintrag im Directory\n");
  //!exit (1);
};
#line 14023 "../diss-hgesser-ulix.tex"
int increase_link_count (int inodenr) {
  struct minix2_inode inode;
  read_inode (inodenr, &inode);
  inode.i_nlinks++;
  write_inode (inodenr, &inode);
  return inode.i_nlinks;
};
#line 14035 "../diss-hgesser-ulix.tex"
#define S_IRWXU  0000700    /* RWX mask for owner */
#define S_IRUSR  0000400    /* R for owner */
#define S_IWUSR  0000200    /* W for owner */
#define S_IXUSR  0000100    /* X for owner */

#define S_IRWXG  0000070    /* RWX mask for group */
#define S_IRGRP  0000040    /* R for group */
#define S_IWGRP  0000020    /* W for group */
#define S_IXGRP  0000010    /* X for group */

#define S_IRWXO  0000007    /* RWX mask for other */
#define S_IROTH  0000004    /* R for other */
#define S_IWOTH  0000002    /* W for other */
#define S_IXOTH  0000001    /* X for other */

#define S_ISUID  0004000    /* set user id on execution */
#define S_ISGID  0002000    /* set group id on execution */
#define S_ISVTX  0001000    /* save swapped text even after use */

#define S_IFMT   0170000    /* mask the fie type part */
#define S_IFIFO  0010000    /* named pipe (fifo) */
#define S_IFCHR  0020000    /* character special */
#define S_IFDIR  0040000    /* directory */
#define S_IFBLK  0060000    /* block special */
#define S_IFREG  0100000    /* regular */
#define S_IFLNK  0120000    /* symbolic link */
#define S_IFSOCK 0140000    /* socket */

void format_rights (int mode, char *str) {
  char c;
  switch (mode & S_IFMT) {
    case S_IFIFO:  c = 'f'; break; 
    case S_IFCHR:  c = 'c'; break;
    case S_IFDIR:  c = 'd'; break;
    case S_IFBLK:  c = 'b'; break;
    case S_IFREG:  c = '-'; break;
    case S_IFLNK:  c = 'l'; break;
    case S_IFSOCK: c = 's'; break;
  };
  str[0] = c;
  str[1] = (mode & S_IRUSR) ? 'r' : '-';
  str[2] = (mode & S_IWUSR) ? 'w' : '-';
  str[3] = (mode & S_IXUSR) ? 'x' : '-';
  str[4] = (mode & S_IRGRP) ? 'r' : '-';
  str[5] = (mode & S_IWGRP) ? 'w' : '-';
  str[6] = (mode & S_IXGRP) ? 'x' : '-';
  str[7] = (mode & S_IROTH) ? 'r' : '-';
  str[8] = (mode & S_IWOTH) ? 'w' : '-';
  str[9] = (mode & S_IXOTH) ? 'x' : '-';
  str[10] = 0;
  return;
};

// struct minix_dir_entry dentry;
void list_dir (int inodenr) {
  char rights[11];
  struct minix2_inode dirinode, inode;
  struct minix_dir_entry dentry;

  // check if this is a directory
  read_inode (inodenr, &inode);
  // printf ("Directory inode's i_mode: %o\n", inode.i_mode);
  if ((inode.i_mode & S_IFMT) != S_IFDIR) {
    printf ("ls: not a directory\n");
    return;
  }

  int i;
  // printf ("DEBUG: in list_dir (%d)...; before loop\n", inodenr);
  for (i=0; i<32; i++) {
    // printf ("DEBUG: in loop, before read_dir_entry \n");
    read_dir_entry (inodenr, i, &dentry);
    // printf ("DEBUG: in loop, after read_dir_entry \n");
    if (dentry.inode != 0) {
      read_inode (dentry.inode, &inode);
      format_rights (inode.i_mode, (char*)&rights);
      printf ("%2d %s %2d %4d %4d %6d %-30s\n", dentry.inode, rights,
              inode.i_nlinks, inode.i_uid, inode.i_gid, inode.i_size, dentry.name);
    }
  }
};
#line 14134 "../diss-hgesser-ulix.tex"
void show_inode_bitmap () {
  // Aufgabe c), benutzt Loesung zu d)
  int no_inodes = 480;  // korrekte Loesung: S-Block auswerten
  int i, j;
  for (i = 0; i<no_inodes; i+=64) {
    // print 64 entries
    printf ("%03d : ", i);  // Position
    for (j = i; j<i+64 && j<no_inodes; j++) {
      printf ("%d", get_imap_bit (j));
      if ((j%8)==7) printf (" ");
    };
    printf ("\n");
  };
  printf ("Belegte Inodes: ");
  for (i = 0; i<480; i++) {
    if (get_imap_bit (i)==1) printf ("%d, ", i);
  };
  printf ("\n");
}

void show_zone_bitmap () {
  // Aufgabe c), benutzt Loesung zu d)
  int no_zones = 1440;  // korrekte Loesung: S-Block auswerten
  unsigned int i, j;
  for (i = 0; i<no_zones-33; i+=64) {
    // -33: Liste ist nur 1440-33 Zeichen lang
    // korrekte Loesung: rausfinden, wie viele Bloecke Datenbloecke sind
    // print 64 entries
    printf ("%04d : ", i+33);  // Position, 1. Eintrag fuer Block 33
    for (j = i; j<i+64 && j<no_zones-33; j++) {
      // print entry j
      printf ("%d", get_zmap_bit (j));
      if ((j%8)==7) printf (" ");
    };
    printf ("\n");
  };
  printf ("Belegte Zones: ");
  for (i = 0; i<1440-33; i++) {
    if (get_zmap_bit (i)==1) printf ("%d, ", i+33);  // +33 !
  };
  printf ("\n");
}
#line 14219 "../diss-hgesser-ulix.tex"
struct filestat { 
  struct int_minix2_inode* int_inode; 
  int pos; 
  short mode;
};
#line 14254 "../diss-hgesser-ulix.tex"
#define MAX_FILES 256
struct filestat status[MAX_FILES] = { 0 };
#line 14275 "../diss-hgesser-ulix.tex"
void relpath_to_abspath (const char *relpath, char *abspath) {
  if (strlen(thread_table[current_task].cwd) > 1) {
    // combine cwd and relpath, add "/" in the middle
    strncpy (abspath, thread_table[current_task].cwd, 256);
  } else {
    strncpy (abspath, "", 256);
  }
  strncpy (abspath+strlen(abspath)+1, relpath, 256-strlen(abspath)-1);
  abspath[strlen(abspath)] = '/';
  printf ("absolute path: %s\n", abspath);
  return;
}

int pathname_to_ino (const char *path) {
  debug_printf ("pathname_to_ino: entered\n");
  int i;
  struct minix2_inode dirinode, inode;
  struct minix_dir_entry dentry;
  char subpath[31];   // maximum name length: 30
  char searchbuf[256];
  char *search = (char*)searchbuf;
  strncpy (search, path, 256);  // do not modify path
  int dirinode_no = 1;     // inode no. of / directory
  int next_dirinode_no;
  short final = 0;              // final = 1 if looking at final part
  
  // check absolute path
  char newpath[256];
  
  if (*search != '/') {
    /*
    if (strlen(thread_table[current_task].cwd) > 1) {
      // combine cwd and path, add "/" in the middle
      strncpy (newpath, thread_table[current_task].cwd, 256);
    } else {
      strncpy (newpath, "", 256);
    }
    strncpy (newpath+strlen(newpath)+1, search, 256-strlen(newpath)-1);
    newpath[strlen(newpath)] = '/';
    */
    relpath_to_abspath (search, newpath);
    search = newpath;
  }
 
  search++;
  
  if (*search == '\0') return 1;    // searching for / : inode 1
  
  // work until end of path reached
  while (*search != '\0') {
    i = 0;
    while (*search != '\0' && *search != '/') {
      subpath[i] = *search;
      search++; i++;
    }
    subpath[i] = '\0';  // terminate subpath string

    if (*search == '\0') final = 1;   // looking at final part of path

    // look up subpath
    debug_printf ("DEBUG: searching for subpath %s in inode %d\n", subpath, dirinode_no);

    next_dirinode_no = -1;
    for (i=0; i<32; i++) {
      // FIX ME: check more than the first 32 entries

     if (dirinode_no==-1)
       printf ("FAIL: calling read_dir_entry (%d); i = %d, subpath = %s\n", dirinode_no, i, subpath);
      
      read_dir_entry (dirinode_no, i, &dentry);
      debug_printf ("pathname_to_ino: after read_dir_entry()\n");
      if (dentry.inode != 0) {
        if (strcmp (dentry.name, subpath) == true) {
          next_dirinode_no = dentry.inode;  // found it!
          break;  // leave for loop
        }
      }
    }
    // now next_dirinode_no is either -1 (not found) or points
    // to next step
    
    if (next_dirinode_no == -1) return -1;   // not found!
    
    dirinode_no = next_dirinode_no;
    
    debug_printf ("DEBUG: subpath = %s, inode = %d\n", subpath, dirinode_no);
    if (*search != '\0') 
      search++;
    else
      break;  // finished
  } // end while
  debug_printf ("DEBUG: returning inode no %d\n", next_dirinode_no);
  return next_dirinode_no;
};
#line 14375 "../diss-hgesser-ulix.tex"
int get_free_inodes_entry () {
  // return an internal inode number
  int i;
  for (i=0; i<MAX_INT_INODES; i++) {
    if (inodes[i].refcount == 0) return i;
  }
  return -1;
}

int get_free_status_entry() {
  // returns an mfd
  int i;
  for (i=0; i<MAX_FILES; i++) {
    if (status[i].int_inode == NULL) return i;
  }
  return -1;
}
#line 14408 "../diss-hgesser-ulix.tex"
int count_open_files = 0;  // number of open files
int count_int_inodes = 0;  // number of internal inodes in use


int mx_open (const char *path, int oflag) {
  debug_printf ("mx_open: entered\n");
  int ext_ino = pathname_to_ino (path);
  debug_printf ("DEBUG: ext_ino = %d\n", ext_ino);
  debug_printf ("mx_open: after pathname_to_ino()\n");
  if (ext_ino == -1) {
    // file not found
    if (oflag & O_CREAT != 0) {
      printf ("DEBUG: mx_open calls creat_empty_file\n");
      ext_ino = creat_empty_file (path, 0644);
    }
    else
      return (-1);  // file not found, and no O_CREAT
  }
    
  int int_ino;  // number of internal inode for this file
#line 14435 "../diss-hgesser-ulix.tex"
short file_already_open = false;
int mfd = get_free_status_entry();

int_ino = -1; 
int i;
if (count_open_files == 0) {
  int_ino = 0;  // first file to be opened
} else {
  for (i = 0; i < MAX_INT_INODES; i++) {
    if (inodes[i].ino == ext_ino) {
      file_already_open = true;
      int_ino = i;
      break;
    }
  }
  // reached end of the loop: file is not open
  if (int_ino == -1) int_ino = get_free_inodes_entry();
}

if (int_ino == -1) {
  // error: no free internal inode available
  return -1;
}

struct int_minix2_inode *inode = &(inodes[int_ino]);

// data for file descriptor
status[mfd].int_inode = inode;
status[mfd].pos       = 0;
status[mfd].mode      = oflag;  // FIX ME: check?
if (oflag == O_APPEND) {} ;

if (file_already_open) {
  
#line 14475 "../diss-hgesser-ulix.tex"
inode->refcount++;   // file is opened once more
#line 14469 "../diss-hgesser-ulix.tex"
} else {
  
#line 14485 "../diss-hgesser-ulix.tex"
// get inode from disk

// copy diskinode[ext_ino] to int_inode[int_ino]
read_inode (ext_ino, (struct minix2_inode*) inode);
inode->ino = ext_ino; // number of external inode
inode->refcount = 1;  // one user
inode->clean = 1;     // as on disk
#line 14471 "../diss-hgesser-ulix.tex"
}
#line 14510 "../diss-hgesser-ulix.tex"
  count_open_files++;
  if (!file_already_open) count_int_inodes++;
  return mfd;
}
#line 14528 "../diss-hgesser-ulix.tex"
int mx_close (int mfd) {
  // printf ("DEBUG: mx_close (%d) called\n", mfd);
  struct filestat *st;
  struct int_minix2_inode *inode;
  
  if (mfd<0 || mfd>=MAX_FILES) return -1;   // wrong mfd number
  
  st = &status[mfd];
  inode = st->int_inode;
  // printf ("DEBUG: &inode = %x\n", inode);
  if (inode == NULL) return -1;             // no open file
  
  // close file
  st->int_inode = NULL;
  inode->refcount--;
  
  // usage count down to 0? Then sync inode
  if (inode->refcount == 0) {
    if (inode->clean == 0) {
      int ext_ino = inode->ino;
      write_inode (ext_ino, (struct minix2_inode*) inode);
    }    
    count_int_inodes--;
  }
  
  count_open_files--;  
  return 0;
}
#line 14561 "../diss-hgesser-ulix.tex"
int mx_sync (int mfd) {
  struct filestat *st;
  struct int_minix2_inode *inode;

  if (mfd<0 || mfd>=MAX_FILES) return -1;   // wrong mfd number
  
  st = &status[mfd];
  inode = st->int_inode;
  if (inode == NULL) return -1;             // no open file
  
  if (inode->clean == 0) {
    int ext_ino = inode->ino;
    write_inode (ext_ino, (struct minix2_inode*) inode);
    inode->clean = 1;   // now it is clean
  }
}
#line 14590 "../diss-hgesser-ulix.tex"
int mx_lseek (int mfd, int offset, int whence) {
  // printf ("DEBUG: mx_lseek, mfd = %d, offset = %d, whence = %d\n", mfd, offset, whence);
  struct filestat *st;
  struct int_minix2_inode *inode;

  if (mfd<0 || mfd>=MAX_FILES) return -1;   // wrong mfd number
  
  st = &status[mfd];
  inode = st->int_inode;
  if (inode == NULL) return -1;             // no open file

  if (whence<0 || whence>2) return -1;      // wrong lseek option
  
  if (st->mode == O_APPEND) return st->pos; // ignore lseek when in APPEND mode
  
  switch (whence) {
    case SEEK_SET: st->pos = offset; break;
    case SEEK_CUR: st->pos += offset; break;
    case SEEK_END: st->pos = inode->i_size + offset;
  };
  
  return st->pos;
}
#line 14634 "../diss-hgesser-ulix.tex"
int mx_read (int mfd, void *buf, int nbyte) {
  debug_printf ("DEBUG: mx_read: %d bytes\n", nbyte);
  struct filestat *st;
  struct int_minix2_inode *inode;

  if (mfd<0 || mfd>=MAX_FILES) return -1;   // wrong mfd number
  
  st = &status[mfd];
  inode = st->int_inode;
  if (inode == NULL) return -1;             // no open file

  if (st->mode == O_WRONLY || st->mode == O_APPEND)
    return -1;                              // cannot read from write-only file
#line 14652 "../diss-hgesser-ulix.tex"
  int startbyte = st->pos;
  if (startbyte >= inode->i_size) return 0;  // nothing to read
  int endbyte = st->pos + nbyte - 1;
  if (endbyte >= inode->i_size) {
    nbyte -= (endbyte - inode->i_size + 1);
    endbyte = inode->i_size - 1;
  }
#line 14664 "../diss-hgesser-ulix.tex"
  int startblock = startbyte / BLOCK_SIZE;
  int endblock   = endbyte / BLOCK_SIZE;
  int curblock = startblock;
#line 14674 "../diss-hgesser-ulix.tex"
  uchar block[BLOCK_SIZE];
  int offset, length;
  int read_bytes = 0;
  int zone;
  while (nbyte > 0) {
    // where is the block?
    // printf ("read_logical_block (%d); ", curblock);   // debug
    zone = fileblocktozone (curblock, inode);  // SOMETHING WRONG IN THERE?
    if (zone == -1) {
      printf ("ERROR: double indirection not implemented. Use smaller files :)\n");
      return -1;
    };

    // printf ("readblock (%d)\n", zone);

    readblock (zone, (uchar*) block);
    if (curblock == startblock) {
      offset = startbyte % BLOCK_SIZE;
      length = min (nbyte, BLOCK_SIZE - offset);
    } else {
      offset = 0;
      length = min (nbyte, BLOCK_SIZE);
    }
    memcpy_debug (buf, block+offset, length);
    
    nbyte -= length;
    buf   += length;
    read_bytes += length;
    curblock++;
    st->pos += length;
  }
  return read_bytes;
}
#line 14719 "../diss-hgesser-ulix.tex"
int fileblocktozone (int blockno, struct int_minix2_inode *inode) {
  int zone;
  int indirect_zone;
  int *zone_ptr;
  uchar indirect_block[BLOCK_SIZE];
  if (blockno < 7) {
    // the first 7 zone numbers (0..6) are in the inode:
    zone = inode->i_zone[blockno];
    debug_printf ("\nDIRECT: %d\n", zone);
  } else if (blockno >= 7 && blockno < 7+BLOCKADDRESSES_PER_BLOCK) {
    // inode holds the address of an indirection block
    // 7..
    indirect_zone = inode->i_zone[7];
    if (indirect_zone == 0) {
      // no indirection block found
      return -2;
    }
    debug_printf ("\nINDIRECTIONS IN: %d, ", indirect_zone);
    readblock (indirect_zone, (uchar *) indirect_block);
    zone_ptr = (int *) indirect_block;
    zone_ptr += (blockno - 7);    
    zone = *zone_ptr;
    debug_printf ("INDIRECT: %d\n", zone);
  } else {
    // double indirection, not implemented
    zone = -1;
  }
  return zone;
}
#line 14858 "../diss-hgesser-ulix.tex"
int create_new_zone (int blockno, struct int_minix2_inode *inode) {
  // printf ("DEBUG: create_new_zone (%d)\n", blockno);
  int zone = request_block ();  // new data block
  if (zone == -1) {
    debug_printf ("cannot reserve data block; disk full\n");
  }
  int indirect_zone;
  int *zone_ptr;
  uchar indirect_block[BLOCK_SIZE] = { 0 };
  if (blockno < 7) {
    // the first 7 zone numbers (0..6) are in the inode:
    inode->i_zone[blockno] = zone;
    debug_printf ("\nADD DIRECT: %d\n", zone);
  } else if (blockno >= 7 && blockno < 7+BLOCKADDRESSES_PER_BLOCK) {
    // inode holds the address of an indirection block
    // 7..
    indirect_zone = inode->i_zone[7];

    // if there is no indirection block yet, create it
    if (indirect_zone == 0) {
      // no indirection block found
      indirect_zone = request_block ();  // data block for indirections
      if (indirect_zone == -1) {
        debug_printf ("cannot reserve indirection block; disk full\n");
        clear_zmap_bit (zone);   // undo reservation of data block
        return -1;
      }
      inode->i_zone[7] = indirect_zone;
    }
    debug_printf ("\nINDIRECTIONS IN: %d, ", indirect_zone);
    readblock (indirect_zone, (uchar *) indirect_block);
    zone_ptr = (int *) indirect_block;
    zone_ptr += (blockno - 7);
    *zone_ptr = zone;   // write information about new data block
    // printf ("DEBUG: writeblock, indirect_zone = %d\n", indirect_zone);
    writeblock (indirect_zone, (uchar *) indirect_block);
    debug_printf ("ADD INDIRECT: %d\n", zone);
  } else {
    // double indirection, not implemented
    zone = -1;
  }
  return zone;
}
#line 14906 "../diss-hgesser-ulix.tex"
int creat_empty_file (const char *path, int mode) { // later
  char abspath[256];
  if (*path != '/')
    relpath_to_abspath (path, (char*)abspath);
  else
    strncpy (abspath, path, 256);

  int i;
  int inodenr = request_inode ();
  struct minix2_inode inode = { 0 };
  for (i = 0; i<10; i++) inode.i_zone[i] = 0;
  inode.i_size = 0;
  inode.i_atime = inode.i_ctime = inode.i_mtime = 9999;
  inode.i_uid = inode.i_gid = 1000;
  inode.i_nlinks = 0;
  inode.i_mode = S_IFREG | mode;
  write_inode (inodenr, &inode);
  // Verzeichniseintrag anlegen
  write_link (inodenr, abspath);
  return inodenr;
}
#line 14763 "../diss-hgesser-ulix.tex"
int mx_write (int mfd, void *buf, int nbyte) {
  // debug_printf ("DEBUG: mx_write: %d bytes\n", nbyte);
  struct filestat *st;
  struct int_minix2_inode *inode;

  if (mfd<0 || mfd>=MAX_FILES) return -1;   // wrong mfd number
  
  st = &status[mfd];
  inode = st->int_inode;
  if (inode == NULL) return -1;             // no open file

  if (st->mode == O_RDONLY)
    return -1;                              // cannot write to read-only file
#line 14781 "../diss-hgesser-ulix.tex"
  int startbyte = st->pos;
  // if (startbyte >= inode->i_size) return 0;  // nothing to read
  int endbyte = st->pos + nbyte - 1;

  /*
  if (endbyte >= inode->i_size) {
    nbyte -= (endbyte - inode->i_size + 1);
    endbyte = inode->i_size - 1;
  }
  */
  
  int startblock = startbyte / BLOCK_SIZE;
  int endblock   = endbyte / BLOCK_SIZE;
  int curblock = startblock;
#line 14801 "../diss-hgesser-ulix.tex"
  uchar block[BLOCK_SIZE];
  int offset, length;
  int written_bytes = 0;
  int zone;
  while (nbyte > 0) {
    // where is the block?
    // printf ("writeblock (%d); ", curblock);   // debug
    zone = fileblocktozone (curblock, inode);
    // printf ("DEBUG: mx_write, fileblocktozone (%d) = %d\n", curblock, zone);
    if (zone == -2 || zone == 0) {
      // block does not yet exist
      zone = create_new_zone (curblock, inode);
    };

    if (zone == -1) {
      printf ("ERROR: double indirection not implemented. Use smaller files :)\n");
      return -1;
    };
    
    if (curblock == startblock) {
      offset = startbyte % BLOCK_SIZE;
      length = min (nbyte, BLOCK_SIZE - offset);
      // printf ("DEBUG: WRITE, FIRST BLOCK, curblock = %d, offset = %d, length = %d\n", curblock, offset, length);
    } else {
      offset = 0;
      length = min (nbyte, BLOCK_SIZE);
    }

    if (offset != 0 || length != BLOCK_SIZE) {
      // writing a partial block -- read first!
      readblock (zone, (uchar*) block);
    }
    memcpy (block+offset, buf, length);
    writeblock (zone, (uchar*) block);
    
    nbyte -= length;
    buf   += length;
    written_bytes += length;
    curblock++;
    st->pos += length;
    
    if (st->pos > inode->i_size)
      inode->i_size = st->pos;
  }
  
  write_inode (inode->ino, (struct minix2_inode*) inode);
  
  
  
  // printf ("inode 3\n"); read_inode (3, inode); show_inode(inode);
  // printf ("inode 4\n"); read_inode (4, inode); show_inode(inode);
  
  return written_bytes;
}
#line 15047 "../diss-hgesser-ulix.tex"
int mx_link(const char *path1, const char *path2) {
  char abspath1[256];
  char abspath2[256];

  // path1: make absolute path if necessary:
  if (*path1 != '/')
    relpath_to_abspath (path1, abspath1);
  else
    strncpy (abspath1, path1, 256);
    
  // check path1 exists
  if (!file_exists(abspath1)) {
    return -1;   // path1 does not exist
  }
  
  // check path1 is not a directory
  if (file_is_directory(abspath1)) {
    printf ("ln: warning: %s is a directory. This option will be removed.\n");
  }
  
  // path2: make absolute path if necessary:
  if (*path2 != '/')
    relpath_to_abspath (path2, abspath2);
  else
    strncpy (abspath2, path2, 256);
  
  // check path2 does NOT exist
  if (file_exists(abspath2)) {
    return -1;   // path2 already exists; no forced linking
  }
  
  // everything ok now :)
  int ino = pathname_to_ino (abspath1);
  write_link (ino, abspath2);
  return 0;
}
#line 15108 "../diss-hgesser-ulix.tex"
int mx_unlink (const char *path) {
  char abspath[256]; char dir[256]; char base[30];
  char ind_block[BLOCK_SIZE];
  struct minix_dir_entry dentry;
  int inodenr, dir_inodenr;
  int i;
  boolean found;

  // make absolute path if necessary:
  if (*path != '/')
    relpath_to_abspath (path, abspath);
  else
    strncpy (abspath, path, 256);

  // check path1 exists
  if (!file_exists(abspath)) {
    printf ("rm: file does not exist\n");
    return -1;   // error: path does not exist
  }
  
  inodenr = pathname_to_ino (path);
  
  printf ("DEBUG: inodenr is %d\n", inodenr);
  
  struct minix2_inode inode;
  read_inode (inodenr, &inode);

  // split path into dir and base
  splitpath (abspath, dir, base);
  
  printf ("DEBUG: abspath = %s, dir = %s, base = %s, ", abspath, dir, base);
  
  dir_inodenr = pathname_to_ino (dir);
  
  printf ("dir_inodenr is %d\n", dir_inodenr);

  // delete entry in directory
  found = false;
  for (i=0; i<32; i++) {
    read_dir_entry (dir_inodenr, i, &dentry);
    if ( dentry.inode==inodenr && strcmp(dentry.name, base) ) {
      dentry.inode = 0;
      memset (dentry.name, 0, 30);
      found = true;
      write_dir_entry (dir_inodenr, i, &dentry);
      break;  // search finished
    }
  }
  if (found==false) return -1;  // error: not found in directory
  
  
  inode.i_nlinks--;   // one name less
  
  if (inode.i_nlinks == 0) {
    
#line 15178 "../diss-hgesser-ulix.tex"
// free direct blocks
for (i=0; i<7; i++) {
  clear_zmap_bit (inode.i_zone[i] - 33);  // mark data block as free
  inode.i_zone[i] = 0;
}

// free indirect blocks
if (inode.i_zone[7] != 0) {
  // indirection block exists
  readblock (inode.i_zone[7], ind_block);
  unsigned int *zoneno;
  zoneno = (unsigned int*)ind_block;      // cast to uint*
  while (*zoneno != 0) {
    clear_zmap_bit (*zoneno - 33);        // mark data block as free
    zoneno++;
  }
  clear_zmap_bit (inode.i_zone[7] - 33);  // mark indir. block as free
  inode.i_zone[7] = 0;
}

// free inode
printf ("Freeing inode %d\n", inodenr);
clear_imap_bit (inodenr);
#line 15163 "../diss-hgesser-ulix.tex"
  }
  
  write_inode (inodenr, &inode);

  return 0;
}
#line 15258 "../diss-hgesser-ulix.tex"
int mx_symlink (char *path1, char *path2) {
  char abspath[256];
  if (*path2 != '/')
    relpath_to_abspath (path2, (char*)abspath);
  else
    strncpy (abspath, path2, 256);
    
  int fd = mx_open (abspath, O_WRONLY | O_CREAT);
  if (fd==-1) return -1;   // error: cannot create file
  mx_write (fd, path1, strlen(path1));
  mx_close (fd);
#line 15279 "../diss-hgesser-ulix.tex"
  int inode_nr = pathname_to_ino (abspath);
  struct minix2_inode inode;
  read_inode (inode_nr, &inode);
  inode.i_mode = S_IFLNK | 0777;
  write_inode (inode_nr, &inode);
  return 0;  // OK.
}
#line 13891 "../diss-hgesser-ulix.tex"
void splitpath (const char *path, char *dirname, char *basename) {
  char p[256];
  strncpy (p, path, 256);    // work on copy
  
  int pos = strlen (p) - 1;
  if (p[pos] == '/') {
    p[pos] = 0; pos--;       // strip trailing /
  }

  // search for / (from back to front)
  for (;;) {
    pos--;
    if (pos == -1) {
      // no single slash found
      strncpy (dirname, ".", 2);
      strncpy (basename, p, 256);
      return;
    }
    if (p[pos] == '/') {
      // slash found
      if (pos==0)
        strncpy (dirname, "/", 2);  // special case /
      else {
        memcpy (dirname, p, pos);
        dirname[pos] = 0;   // remove trailing /
      }
      strncpy (basename, p + pos + 1, 30);
      return;
    }
  }
}

char *basename (char *path) {
  static char bname[30];
  static char dname[256];
  splitpath (path, dname, bname);
  return (char *)bname;
}

char *dirname (char *path) {
  static char bname[30];
  static char dname[256];
  splitpath (path, dname, bname);
  return (char *)dname;
}
#line 14960 "../diss-hgesser-ulix.tex"
char *getcwd (char *buf, int size) {
  strncpy (buf, thread_table[current_task].cwd, size);
  return buf;
}

boolean file_exists (const char *path) {
  int ino = pathname_to_ino (path);
  if (ino == -1) return false;
  return true;
}

boolean file_is_directory (const char *path) {
  int ino = pathname_to_ino (path);

  // exists?
  if (ino == -1)
    return false;

  // is directory?
  struct minix2_inode inode;
  read_inode (ino, &inode);
  if ((inode.i_mode & S_IFDIR) == 0)
    return false;
    
  return true;
}

int chdir (const char *path) {
  char abspath[256];
  // check relative/absolute path
  if (*path != '/')
    relpath_to_abspath (path, abspath);
  else
    strncpy (abspath, path, 256);
    
  if (file_is_directory (abspath)) {
    strncpy (thread_table[current_task].cwd, abspath, 256);
    return 0;
  } else {
    return -1;  // error
  }
}
#line 15534 "../diss-hgesser-ulix.tex"
int serial_disk_enter (int pid, short direction, uint secno, uint address) {
  // TODO: lock
  
  // check if buffer is full
  if ( (serial_disk_buffer_end+1) % 100 == serial_disk_buffer_start )
    return -1;   // fail
  
  struct serial_disk_buffer_entry *entry;
  entry = &serial_disk_buffer[serial_disk_buffer_end];
  entry->status = BUF_STAT_NEW;
  entry->pid = pid;
  entry->direction = direction;
  entry->secno = secno;
  entry->address = address;
  
  short tmp = serial_disk_buffer_end;
  serial_disk_buffer_end = (serial_disk_buffer_end+1) % 100;
  // TODO: unlock
  
  return tmp;   // tell the caller what entry number we used
}
#line 15562 "../diss-hgesser-ulix.tex"
void serial_disk_remove_top () {
  if ( (serial_disk_buffer_start != serial_disk_buffer_end) &&
       (serial_disk_buffer[serial_disk_buffer_start].status == BUF_STAT_FINISHED) 
     ) {
    serial_disk_buffer_start++;
    serial_disk_buffer_start %= 100;
  }
  return;
}
#line 15583 "../diss-hgesser-ulix.tex"
void serial_disk_send_sector_number (uint secno) {
  uart2putc ((unsigned char)(secno%256));  // lowest byte
  secno /= 256;
  uart2putc ((unsigned char)(secno%256));  // 2nd lowest byte
  secno /= 256;
  uart2putc ((unsigned char)(secno%256));  // 3rd lowest byte
  secno /= 256;
  uart2putc ((unsigned char)(secno%256));  // highest byte
  return;
}

int serial_disk_non_blocking_rw () {
  if (serial_disk_buffer_start == serial_disk_buffer_end)
    return -1;   // buffer is empty
  
  struct serial_disk_buffer_entry *entry;
  entry = &serial_disk_buffer[serial_disk_buffer_start];
  
  if (entry->direction == BUF_WRITE) {
    // write
    uart2putc (CMD_PUT);
    serial_disk_send_sector_number (entry->secno);
    unsigned char *addressptr;
    addressptr = (char*) (entry->address);
    int i;
    for (i=0; i<1024; i++) {
      uart2putc (*addressptr);
      addressptr++;
    };
    
    entry->status = BUF_STAT_FINISHED;
    serial_disk_buffer_start++;
    serial_disk_buffer_start %= 100;
  } else if (entry->direction == BUF_READ) {
    // read
    uart2putc (CMD_GET);
    serial_disk_send_sector_number (entry->secno);
    serial_disk_reader = 1;  // we're in read mode,
       // this value gets changed in the IRQ handler
    
    // wait for data and show it... BEFORE CHANGING buffer_start
    // printf ("waiting... ");
    while (serial_disk_reader == 1) asm ("hlt");
    // printf (" done waiting.\n");
        
    entry->status = BUF_STAT_FINISHED;
    // DEBUG, // printf ("%s\n", entry->sector);
    serial_disk_buffer_start++;
    serial_disk_buffer_start %= 100;
    // copy buffer to target memory location
    memcpy ((char*)(entry->address), (char*)&(entry->sector), SECSIZE);
  }
}
#line 15647 "../diss-hgesser-ulix.tex"
int kernel_read_sector (int secno, char* buf) {
  // printf ("DEBUG FS: kernel read sector %d\n", secno);
  serial_disk_enter (-1, BUF_READ, secno, (uint)buf);
  serial_disk_non_blocking_rw ();
}

int kernel_write_sector (int secno, char* buf) {
  // printf ("DEBUG FS: kernel write sector %d\n", secno);
  serial_disk_enter (-1, BUF_WRITE, secno, (uint)buf);
  serial_disk_non_blocking_rw ();
}
#line 15683 "../diss-hgesser-ulix.tex"
void serial_disk_init () {
  uart2putc (CMD_STAT);

}
#line 16130 "../diss-hgesser-ulix.tex"
void fdc_sleep () {
  if ((current_task > 1) && scheduler_is_active) {
    // block process
    /// asm ("sti");
    /// while (fdc_is_busy == true) debug_printf("-");   // wait for other FDC operation
    /// asm ("cli");
    fdc_is_busy = true;
    thread_table[current_task].state = TSTATE_WAITFLP;
    remove_from_ready_queue (current_task);
    add_to_blocked_queue (current_task, &floppy_queue);
      
    // try: active waiting
    /*
    ENABLE_SCHEDULER;
    asm("sti");
    while ( thread_table[current_task].state == TSTATE_WAITFLP ) ;
    */
    
    // calling yield (via syscall 66)
    debug_printf ("fdc_sleep going to call yield()\n");
    asm ("sti");
    asm (".intel_syntax noprefix; \
      mov eax, 66;; \
      int 0x80;; \
      .att_syntax; ");
  }
  fdc_is_busy = false;
  return;
};
#line 16167 "../diss-hgesser-ulix.tex"
void fdc_wakeup () {
  thread_id start_pid = floppy_queue.next;
  if (start_pid != 0) {
    // only if there are queue entries...
    thread_id search_pid = start_pid;
    do {
      // TODO: WARUM TESTE ICH HIER AUF cur_vt?
      // if (thread_table[search_pid].terminal == cur_vt) {
      if (true) {
        thread_table[search_pid].state = TSTATE_READY;
        deblock (search_pid, &floppy_queue);
        break;
      } else {
        search_pid = thread_table[search_pid].next;
      }
    } while (search_pid != start_pid && search_pid != 0);
  }
  return;
}
#line 16207 "../diss-hgesser-ulix.tex"
/**** FROM proc/i386.h *********/
static /* inline */ void outb_delay(unsigned short __port, unsigned char __value) {
  __asm__ __volatile__("outb %0,%1; \
                        outb %%al,$0xE0"      :
                       /* no output */        :
                       "a" (__value),
                       "dN" (__port)           
                       /* "eax","edx" */ );
}

static /* inline */ unsigned char inb_delay(unsigned short __port) {
  unsigned char data;

  __asm__ __volatile__("inb %1,%0; \
                        outb %%al,$0xE0"      :
                       "=a" (data)            :
                       "dN" (__port)           
                       /* "eax","edx" */ );
  return data;
}


/**** FROM arch/pc/cmos.c *********/

unsigned char
read_cmos(unsigned char address) {
  outb_delay(0x70, address);
  return inb_delay(0x71);
}



/**** FROM dma.c *********/

unsigned char dma_page_reg   [8] = { 0x87,0x83,0x81,0x82,0x00,0x8B,0x89,0x8A };
unsigned char dma_address_reg[8] = { 0x00,0x02,0x04,0x06,0xC0,0xC4,0xC8,0xCC };
unsigned char dma_count_reg  [8] = { 0x01,0x03,0x05,0x07,0xC2,0xC6,0xCA,0xCE };


void enable_dma_channel(int channel) {
  if (channel < 4)
    outb_delay(DMA0_INIT, channel);
  else
    outb_delay(DMA1_INIT, channel & 3);
}

void disable_dma_channel(int channel) {
  if (channel < 4)
    outb_delay(DMA0_INIT, channel | 4);
  else
    outb_delay(DMA1_INIT, (channel & 3) | 4);
}

void set_dma_channel_mode(int channel, int mode) {
  if (channel < 4)
    outb_delay(DMA0_MODE, mode | channel);
  else
    outb_delay(DMA1_MODE, mode | (channel & 3));
}


void clear_dma_channel_flipflop(int channel) {
  outb_delay((channel < 4) ? DMA0_FLIPFLOP : DMA1_FLIPFLOP, 0);
}

void set_dma_channel_count(int channel, long count) {
  count--;

  if (channel < 4) {
    outb_delay(dma_count_reg[channel], (unsigned char)count);
    outb_delay(dma_count_reg[channel], (unsigned char)(count >> 8));
  } else {
    outb_delay(dma_count_reg[channel], (unsigned char)(count >> 1));
    outb_delay(dma_count_reg[channel], (unsigned char)(count >> 9));
  }
}

void set_dma_channel_address(int channel, unsigned char *address) {
  if (channel < 4) {
    outb_delay(dma_address_reg[channel], (unsigned char)(unsigned)address);
    outb_delay(dma_address_reg[channel], (unsigned char)((unsigned)address >>8));
  } else {
    outb_delay(dma_address_reg[channel], (unsigned char)((unsigned)address >>1));
    outb_delay(dma_address_reg[channel], (unsigned char)((unsigned)address >>9));
  }
}

void set_dma_channel_page(int channel, int page) {
  outb_delay(dma_page_reg[channel], (channel < 4) ? page : page & 0xFE);
}



/**** FROM floppy.c ******/

/*
 * Initialize the DMA floppy channel.
 */

static void dma_init(char *address, int count) {
  disable_dma_channel(FLOPPY_CHANNEL);
  clear_dma_channel_flipflop(FLOPPY_CHANNEL);
  set_dma_channel_mode(FLOPPY_CHANNEL,
    (fdc_cmd == FLOPPY_READ) ? DMA_READ_MODE : DMA_WRITE_MODE);
  set_dma_channel_count(FLOPPY_CHANNEL, count);
  set_dma_channel_address(FLOPPY_CHANNEL, address);
  set_dma_channel_page(FLOPPY_CHANNEL, (unsigned)address >> 16);
  enable_dma_channel(FLOPPY_CHANNEL);
}
#line 16323 "../diss-hgesser-ulix.tex"
void fdc_interrupt(struct regs* r) {
  fdc_timeout = 0;
  debug_printf ("FDC: interrupt\n");
  if (!fdc_waits_interrupt)
    fdc_need_reset = 1;  // unexepected floppy interrupt, reset controller
  fdc_waits_interrupt = 0;
  fdc_wakeup();
}
#line 16336 "../diss-hgesser-ulix.tex"
static void fdc_start_motor(void) {
  int i;

  if (current_fdd->motor) return;
  current_OUTPUT = FLOPPY_CONTROLLER_ENABLE | FLOPPY_DMAINT_ENABLE |
                   fdc_drive | (16 << fdc_drive);
  outb_delay(FLOPPY_OUTPUT, current_OUTPUT);
  current_fdd->motor = 1;
  fdd[!fdc_drive].motor = 0;
  for (i = 0; i < 500000; i++);
}

static void fdc_stop_motor(void) {
  outb_delay(FLOPPY_OUTPUT,
             current_OUTPUT = FLOPPY_CONTROLLER_ENABLE | FLOPPY_DMAINT_ENABLE |
             fdc_drive);

  fdd[0].motor = fdd[1].motor = 0;
}
#line 16360 "../diss-hgesser-ulix.tex"
/*
 * The floppy timer.  Called in order to stop the floppy motor if
 * there has been no floppy access in the past two seconds.
 */

void fdc_timer(void) {
  if (fdc_waits_interrupt && ++fdc_ticks > HZ * 2) {
    fdc_waits_interrupt = 0;
    fdc_timeout = 1;
    fdc_wakeup();
  } else if ((fdd[0].motor | fdd[1].motor) &&
             // fdc_rw_mutex && 
             ~(fdc_rw_lock->l) &&
             !--fdc_ticks_till_motor_stops) {
    fdc_stop_motor();
  }
}


/*
 * Wait for an interrupt.  Force a reset on timeout.
 */

static int wait_fdc_interrupt(void) {
  fdc_ticks = 0;
  fdc_waits_interrupt = 1;
  fdc_sleep();

  if (fdc_timeout) {
    fdc_need_reset = 1;
    printf("FDC: drive %d timeout\n", fdc_drive);
  }

  return fdc_timeout;
}


/*
 * Read the results from the floppy controller.
 */

static int fdc_getresults(void) {
  int i, results;
  unsigned char status;

  if (fdc_need_reset) { printf ("exit\n"); return 0; } ;

  for (results = i = 0; i < 30000; i++) {
    status = inb_delay(FLOPPY_STATUS) & FLOPPY_NEW_BYTE;
    if (status == FLOPPY_MASTER) return 1;
    if (status != FLOPPY_NEW_BYTE) continue;
    if (results == MAX_FLOPPY_RESULTS) break;
    fdc_results[results++] = inb_delay(FLOPPY_COMMAND);
  }

  printf("FDC: reply error\n");
  fdc_need_reset = 1;
  return 0;
}


/*
 * Send a byte to the floppy controller.
 */

static void fdc_out(unsigned char data) {
  int i;
  unsigned char status;

  for (i = 0; i < 10000; i++) {
    status = inb_delay(FLOPPY_STATUS) & (FLOPPY_MASTER | FLOPPY_DIRECTION);
    if (status != FLOPPY_MASTER) continue;
    outb_delay(FLOPPY_COMMAND, data);
    return;
  }

  printf("FDC: can't send byte %w to controller\n", data);
  fdc_need_reset = 1;
}


static void fdc_mode(void) {
  fdc_out(FLOPPY_SPECIFY);
  fdc_out(current_fdd_type->spec1);
  fdc_out(FLOPPY_SPEC2);
  outb_delay(FLOPPY_RATE, current_fdd_type->rate & ~0x40);
}


static void fdc_reset(void) {
  int i;

  //! DEBUG(1, "FDC: reseting...\n");

  // debug_printf ("DEBUG: cli, in fdc_reset\n");
  __asm__ __volatile__("cli");  // disable();
  outb_delay(FLOPPY_OUTPUT, FLOPPY_DMAINT_ENABLE);

  for(i = 0; i < 10000; i++) __asm__("nop");

  outb_delay(FLOPPY_OUTPUT,
             current_OUTPUT = FLOPPY_CONTROLLER_ENABLE | FLOPPY_DMAINT_ENABLE);

  fdc_need_reset = 0;

  fdd[0].calibrated = fdd[1].calibrated = 0;
  fdd[0].motor      = fdd[1].motor      = 0;

  if (wait_fdc_interrupt())
    printf("FDC: can't reset controller (timeout)\n");

  fdc_out(FLOPPY_SENSE);

  if (!fdc_getresults())
    printf("FDC: can't reset controller\n");
}


static int fdc_recalibrate(void) {
  if (fdc_need_reset) return 0;

  //! DEBUG(1, "FDC: recalibrating drive %d...\n", fdc_drive);

  // debug_printf ("DEBUG: cli, in fdc_recalibrate\n");
  __asm__ __volatile__("cli");  // disable();
  fdc_start_motor();
  fdc_out(FLOPPY_RECALIBRATE);
  fdc_out(fdc_drive);

  if (fdc_need_reset)
    return 0;

  if (wait_fdc_interrupt())
    return 0;

  fdc_out(FLOPPY_SENSE);

  if (!fdc_getresults())
    goto bad_recalibration;

  if ((fdc_results[0] & TEST_BITS) != SEEK_OK || fdc_results[1])
    goto bad_recalibration;

  current_fdd->current_track = INVALID_TRACK;
  return current_fdd->calibrated = 1;

  bad_recalibration:

  printf("FDC: can't recalibrate\n");
  fdc_need_reset = 1;
  return 0;
}


static int fdc_seek(void) {
  if (fdc_need_reset) return 0;

  if (!current_fdd->calibrated)
    if (!fdc_recalibrate())
      return 0;

  if (fdc_track == current_fdd->current_track) return 1;

  // debug_printf ("DEBUG: cli, in fdc_seek\n");
  __asm__ __volatile__("cli");  // disable();

  if (!current_fdd->motor) return 0;

  fdc_out(FLOPPY_SEEK);
  fdc_out(fdc_head << 2 | fdc_drive);
  fdc_out(fdc_track);
  
  if (fdc_need_reset) return 0;

  if (wait_fdc_interrupt()) return 0;

  current_fdd->current_track = fdc_track;
  fdc_out(FLOPPY_SENSE);

  if (!fdc_getresults()) return 0;

  if ((fdc_results[0] & TEST_BITS) != SEEK_OK ||
      fdc_results[1] != fdc_track * (current_fdd_type->trackstep + 1))
    return 0;

  // printf ("fdc_seek returns 1\n");
  return 1;
}


/*
 * Perform the actual transfer.
 */

static int fdc_transfer(void) {
  int sectors;

  // debug_printf ("DEBUG: cli, in fdc_transfer\n");
  __asm__ __volatile__("cli");  // disable();

  if (fdc_need_reset || !current_fdd->motor || !current_fdd->calibrated)
    return 0;

  // printf ("fdc_transfer: calling dma_init... ");
  dma_init(fdc_buf +
           ((fdc_head * current_fdd_type->sectors + fdc_sector - 1) << 9),
           fdc_nsects * (1 << (current_fdd_type->sectorsize + 7)));
  // printf ("done\n");

  fdc_mode();
  fdc_out(fdc_cmd);
  fdc_out(fdc_head << 2 | fdc_drive);
  fdc_out(fdc_track);
  fdc_out(fdc_head);
  fdc_out(fdc_sector);
  fdc_out(current_fdd_type->sectorsize);      /* 2 = 512 bytes/sector.  */
  fdc_out(current_fdd_type->sectors);         /* End of track.  */
  fdc_out(current_fdd_type->gap);             /* Gap length.  */
  fdc_out(FLOPPY_DTL);                        /* Data length.  */

  // printf ("fdc_transfer: alls fdc_out's done\n");

  if (fdc_need_reset) return 0;

  if (wait_fdc_interrupt()) return 0;

  // printf ("fdc_transfer: calling fdc_getresults... ");
  if (!fdc_getresults()) return 0;
  // printf ("done\n");

  if (fdc_cmd == FLOPPY_WRITE && fdc_results[1] & WRITE_PROTECTED) {
    fdc_out(FLOPPY_SENSE);
    // printf ("fdc_transfer: calling fdc_getresults (#2)... ");
    fdc_getresults();
    // printf ("done\n");
    return -1;
  }

  if ((fdc_results[0] & TEST_BITS) != TRANSFER_OK ||
      fdc_results[1] || fdc_results[2])
    goto bad_transfer;

  sectors = (fdc_results[3] - fdc_track) * (current_fdd_type->sectors << 1) +
            (fdc_results[4] - fdc_head) * current_fdd_type->sectors +
            fdc_results[5] - fdc_sector;

  if (sectors == fdc_nsects) return 1;

  bad_transfer:

  current_fdd->calibrated = 0;
  return 0;
}


static int fdc_command(int cmd, int drive, int track, int sector, int nsects) {
  int err;

  fdc_cmd    = cmd;
  fdc_drive  = drive;
  fdc_track  = track;
  fdc_head   = sector / current_fdd_type->sectors;
  fdc_sector = sector % current_fdd_type->sectors + 1;
  fdc_nsects = nsects;

  fdc_ticks_till_motor_stops = 3 * HZ;

  for (err = 0; err < MAX_FLOPPY_ERRORS; err++) {
    if (fdc_need_reset)
      fdc_reset();

    fdc_start_motor();

    if (!fdc_seek()) {
      debug_printf("FDC: seek error on drive %d\n", fdc_drive);
	  continue;
	}

	switch (fdc_transfer()) {
      case -1: printf("FDC: disk in drive %d is write protected\n", fdc_drive);
               return 0;
      case  0: continue;
      case  1: return 1;
	}
  }
  return 0;
}


int fdc_open(int minor, int flags) {
  //! DEBUG(9, "(%d/%d)\n", FDC_MAJOR, minor);

  if (minor < 0 || minor >= MAX_FDCS || !fdd[minor].present) {
    //! DEBUG(9, "no such device\n");
    return -ENXIO;
  }

  //! down(&fdc_oc_mutex, WAIT_DEVICE_BUSY);
  LOCK (fdc_oc_lock);

  if (!fdc_minor_info[minor].in_use) {
    fdd[minor].calibrated    = 0;
    fdd[minor].current_track = INVALID_TRACK;
    fdd[minor].motor         = 0;
    fdc_minor_info[minor].in_use = 1;
  }

  //! up(&fdc_oc_mutex);
  UNLOCK (fdc_oc_lock);

  return 0;
}


int fdc_close(int minor) {
  //! DEBUG(9, "(%d/%d)\n", FDC_MAJOR, minor);

  //! down(&fdc_oc_mutex, WAIT_DEVICE_BUSY);
  LOCK (fdc_oc_lock);

  /* It should never enter on the 'true' branch of this 'if'.
     Maybe this should be removed.  */

  if (!fdc_minor_info[minor].in_use) {
    printf("FDC: trying to close unused device %d\n", minor);
    //! up(&fdc_oc_mutex);
    UNLOCK (fdc_oc_lock);
    return -EBUSY;
  }

  fdc_minor_info[minor].in_use = 0;

  //! up(&fdc_oc_mutex);
  UNLOCK (fdc_oc_lock);
  
  return 0;
}


int fdc_read(int minor, blk_request *br) {
  int spt;                            /* Sectors per track.  */
  int spb;                            /* Sectors per file system block.  */
  int i, buf_no;
  unsigned address = 0, index = 0;
  int device = minor, ctrack, csector;
  int block, cblock, nblocks, cnblocks;
  int good_sectors, total_good_sectors = 0;

  //! down(&fdc_rw_mutex, WAIT_DEVICE_BUSY);
  LOCK (fdc_rw_lock);

  current_fdd      = &fdd[device];
  current_fdd_type = &fdd_type[current_fdd->type];

  spb     = br->blksz / FDC_BLKSZ;
  block   = br->block   * spb;
  nblocks = br->nblocks * spb;


  /* Check the request.  */
  if (block   <  0 || block   >= current_fdd_type->total_sectors ||
      nblocks <= 0 || nblocks >  current_fdd_type->total_sectors ||
      block + nblocks         >  current_fdd_type->total_sectors)
    PANIC("bad request (cmd=r dev=%d blk=%d nblk=%d buf=%d)\n",
          device, br->block, br->nblocks, br->buf_no);

  spt = current_fdd_type->sectors << 1;
  buf_no = br->buf_no;

  //! DEBUG(9, "(cmd=r dev=%d blk=%d nblk=%d buf=%d)\n",
  //!       device, br->block, br->nblocks, br->buf_no);

  for (cblock = block; nblocks; cblock += cnblocks, nblocks -= cnblocks) {
    ctrack   = cblock / spt;
    csector  = cblock % spt;
    cnblocks = min(nblocks, spt - csector);

    if (fdc_command(FLOPPY_READ, device, ctrack, csector, cnblocks))
      good_sectors = cnblocks;
	else
      for (good_sectors = i = 0; i < cnblocks; good_sectors++, i++) {
        printf("FDC: reading one sector at a time (%d/%z/%z)...\n",
               device, ctrack, csector + i);
        if (fdc_command(FLOPPY_READ, device, ctrack, csector+i,1) == 0)
          break;
      }

    for (i = 0; i < cnblocks; index++, i++) {
      if (i < good_sectors) {
        if (index == 0)
          address = (unsigned)buf_address(buf_no);
        memcpy_debug((void *)(address + (index << 9)),
               &fdc_buf[(csector + i) << 9], FDC_BLKSZ);
        buf_vect[buf_no].valid = 1;
      } else
        buf_vect[buf_no].valid = 0;

      if (index == spb - 1) {
        buf_no = buf_vect[buf_no].next;
        index = -1;
      }
    }

    total_good_sectors += good_sectors;
    if (good_sectors != cnblocks) break;
  }

  //! up(&fdc_rw_mutex);
  UNLOCK (fdc_rw_lock);

  return total_good_sectors * FDC_BLKSZ;
}


int fdc_read_sector(int device, int block, char* buffer) {
  // READ A 512 BYTE SECTOR  (DISC SECTOR SIZE = 512)
  // 1.4MB: 80 tracks, 18 sectors, sectorsize=2. 80x18x2=2880
  int spt;                            /* Sectors per track.  */
  int i, buf_no;
  unsigned address = 0, index = 0;
  int ctrack, csector;
  int cnblocks;
  int good_sectors, total_good_sectors = 0;

  //! down(&fdc_rw_mutex, WAIT_DEVICE_BUSY);
  LOCK (fdc_rw_lock);

  current_fdd      = &fdd[device];
  current_fdd_type = &fdd_type[current_fdd->type];

  spt = current_fdd_type->sectors << 1;  // 36 ??

  ctrack   = block / spt;
  csector  = block % spt;
  cnblocks = 1;

  if (fdc_command(FLOPPY_READ, device, ctrack, csector, cnblocks))
    good_sectors = cnblocks;
  else
    good_sectors = 0;

  if (good_sectors == 1) {
    debug_printf ("DEBUG: fdc_read_sector: accessing FDC buffer\n");
    memcpy_debug((void *)buffer,
           &fdc_buf[csector << 9]+0xd0000000, FDC_BLKSZ);
  }

  //! up(&fdc_rw_mutex);
  UNLOCK (fdc_rw_lock);

  return good_sectors * FDC_BLKSZ;
}

int fdc_write_sector(int device, int block, char* buffer) {
  // READ A 512 BYTE SECTOR  (DISC SECTOR SIZE = 512)
  // 1.4MB: 80 tracks, 18 sectors, sectorsize=2. 80x18x2=2880
  int spt;                            /* Sectors per track.  */
  int i, buf_no;
  unsigned address = 0, index = 0;
  int ctrack, csector;
  int cnblocks;
  int good_sectors, total_good_sectors = 0;

  //! down(&fdc_rw_mutex, WAIT_DEVICE_BUSY);
  LOCK (fdc_rw_lock);

  current_fdd      = &fdd[device];
  current_fdd_type = &fdd_type[current_fdd->type];

  spt = current_fdd_type->sectors << 1;  // 36 ??

  ctrack   = block / spt;
  csector  = block % spt;
  cnblocks = 1;

  memcpy_debug( &fdc_buf[csector << 9]+0xd0000000,
          (void *)buffer, FDC_BLKSZ);

  if (fdc_command(FLOPPY_WRITE, device, ctrack, csector, cnblocks))
    good_sectors = cnblocks;
  else
    good_sectors = 0;


  //! up(&fdc_rw_mutex);
  UNLOCK (fdc_rw_lock);

  return good_sectors * FDC_BLKSZ;
}


int fdc_write(int minor, blk_request *br) {
  int spt;                            /* Sectors per track.  */
  int spb;                            /* Sectors per file system block.  */
  int i, buf_no;
  unsigned address = 0, index = 0;
  int device = minor, ctrack, csector;
  int block, cblock, nblocks, cnblocks;
  int good_sectors, total_good_sectors = 0;

  //! down(&fdc_rw_mutex, WAIT_DEVICE_BUSY);
  LOCK (fdc_rw_lock);

  current_fdd      = &fdd[device];
  current_fdd_type = &fdd_type[current_fdd->type];

  spb     = br->blksz / FDC_BLKSZ;
  block   = br->block   * spb;
  nblocks = br->nblocks * spb;


  /* Check the request.  */

  if (block   <  0 || block   >= current_fdd_type->total_sectors ||
      nblocks <= 0 || nblocks >  current_fdd_type->total_sectors ||
      block + nblocks         >  current_fdd_type->total_sectors)
	PANIC("%s (cmd=w dev=%d blk=%d nblk=%d buf=%d)\n",
          ERR_BADREQ, device, br->block, br->nblocks, br->buf_no);

  spt = current_fdd_type->sectors << 1;
  buf_no = br->buf_no;

  //! DEBUG(9, "(cmd=w dev=%d blk=%d nblk=%d buf=%d)\n",
  //!       device, br->block, br->nblocks, br->buf_no);

  for (cblock = block; nblocks; cblock += cnblocks, nblocks -= cnblocks) {
    ctrack   = cblock / spt;
    csector  = cblock % spt;
    cnblocks = min(nblocks, spt - csector);

    for (i = 0; i < cnblocks; index++, i++) {
      if (index == 0) address = (unsigned)buf_address(buf_no);
      memcpy_debug(&fdc_buf[(csector + i) << 9],
             (void *)(address + (index << 9)), FDC_BLKSZ);

      if (index == spb - 1) {
        buf_no = buf_vect[buf_no].next;
        index = -1;
      }
    }

    if (fdc_command(FLOPPY_WRITE, device, ctrack, csector, cnblocks))
      good_sectors = cnblocks;
    else
      for (good_sectors = i = 0; i < cnblocks; good_sectors++, i++) {
        printf("FDC: writing one sector at a time (%d/%z/%z)...\n",
               device, ctrack, csector + i);
        if (fdc_command(FLOPPY_WRITE, device, ctrack,csector+i,1) == 0)
          break;
      }

    if (good_sectors != cnblocks) break;
    total_good_sectors += good_sectors;
  }

  //! up(&fdc_rw_mutex);
  UNLOCK (fdc_rw_lock);

  return total_good_sectors * FDC_BLKSZ;
}

int fdc_ioctl(int minor, int cmd, void *argp) {
  switch (cmd) {
    case IOCTL_GETBLKSZ:          /* Get device block size.  */
      *(int *)argp = FDC_BLKSZ;
      break;

    case IOCTL_GETDEVSZ:          /* Get device size (in no of blocks).  */
      *(int *)argp =  fdd_type[fdd[minor].type].total_sectors;
      break;

    default:
      return -EINVAL;
  }

  return 0;
}

/*
WOFUER BRAUCH ICH DAS?
int fdc_lseek(int minor, __off_t offset) {
  if (minor < fdc_driver.minors)
    return offset;

  return -ESPIPE;
}
*/


int fdc_map_type (int t) {
  // we support types 2 (1.2 MB), 4 (1.44 MB), and 5 (2.88 MB)
  switch (t) {
    case 2: return 0;
    case 4: return 1;
    case 5: return 3;
    default: return -1;
  }
}

/*
 * Initialize the driver data structures.  Detect the number of floppies
 * and their type from the CMOS.  Also register the driver.
 */

int fdc_init(void) {
  // initialize locks
  fdc_oc_lock = get_new_lock ();
  fdc_rw_lock = get_new_lock ();
  debug_printf ("DEBUG: &fdc_oc_lock->l = %x\n", &fdc_oc_lock->l);
  debug_printf ("DEBUG: &fdc_rw_lock->l = %x\n", &fdc_rw_lock->l);

  int type, fdd_type_byte = read_cmos(0x10);

  type = fdd_type_byte >> 4;

  if ((fdd[0].present = (type == 2 || type == 4 || type == 5 )))
    // fdd[0].type = (type != 2);
    fdd[0].type = fdc_map_type (type);

  printf("FDC: fda is %s, ", fdd_drive_name[type]);

  type = fdd_type_byte & 0x0F;

  if ((fdd[1].present = (type == 2 || type == 4 || type == 5 )))
    // fdd[1].type = (type != 2);
    fdd[1].type = fdc_map_type (type);

  printf("fdb is %s\n", fdd_drive_name[type]);

  irq_install_handler(6, fdc_interrupt);
  outportb (0x3F7,  0); // FDC Reset
  outportb (0x3F2, 12); // Enable DMA, disable Reset

  
  // TEST FDC
  char fbuf[512];
  fdc_read_sector(0, 39, (char*)&fbuf); fbuf[60]='\0'; 
  // printf ("sector %d: %s ...\n", 39, &fbuf);
  // fdc_read_sector(0, 40, (char*)&fbuf); fbuf[60]='\0'; 
  // printf ("sector %d: %s ...\n", 40, &fbuf);
  
  // memcpy(&fbuf, "HALLO LEUTE - WIE GEHT ES?", 27);
  // fdc_write_sector(0, 40, (char*)&fbuf);
  

  // TESTS
  
  // simplefs_ls();
  /*
  char xbuf[51];
  int fd = simplefs_open ("makefs.c");
  int counter;
  for (;;) {
    counter = simplefs_read (fd, (char*)&xbuf, 50);
    xbuf[counter] = '\0';
    printf ("%s", xbuf);
    if (counter==0) break;
  };
  printf ("\n");
  */
  asm ("sti");
  
  return 0; // register_driver((generic_driver *)&fdc_driver);
}
#line 17041 "../diss-hgesser-ulix.tex"
void syscall_read_sector (struct regs *r) {
  // printf ("  sector: %d\n" ,r->ebx);
  fdc_read_sector(1, r->ebx, (char*)r->ecx);
};

void syscall_write_sector (struct regs *r) {
  fdc_write_sector(1, r->ebx, (char*)r->ecx);
};

void syscall_open (struct regs *r) {
  // r->eax = simplefs_open ((char*) r->ebx);
  debug_printf ("syscall_open called\n");
  r->eax = mx_open ((char*) r->ebx, r->ecx);
  return;
};

void syscall_close (struct regs *r) {
  int gfd = r->ebx;
  debug_printf ("syscall_close (fd = %d) called\n", gfd);
  // simplefs_close (gfd);
  mx_close (gfd);
};

void syscall_read (struct regs *r) {
  // ebx: fd
  // ecx: *buf
  // edx: nbytes
  int gfd = r->ebx;
  char* buf = (char*) r->ecx;
  int nbytes = r->edx;
  // r->eax = simplefs_read (gfd, buf, nbytes);
  r->eax = mx_read (gfd, buf, nbytes);
  // debug_printf ("syscall_read finished\n");
};

void syscall_write (struct regs *r) {
  // ebx: fd
  // ecx: *buf
  // edx: nbytes
  int gfd = r->ebx;
  char* buf = (char*) r->ecx;
  int nbytes = r->edx;
  // r->eax = simplefs_write (gfd, buf, nbytes);
  r->eax = mx_write (gfd, buf, nbytes);
  debug_printf ("syscall_write finished\n");
};

void syscall_lseek (struct regs *r) {
  // ebx: fd
  // ecx: offset
  // edx: whence
  r->eax = mx_lseek (r->ebx, r->ecx, r->edx);
};

void syscall_ls (struct regs *r) {
  // ebx: path
  char *path = (char*) r->ebx;
  int inode = pathname_to_ino (path);
  if (inode == -1)
    printf ("ls: %s: no such directory\n", path);
  else {
    printf ("directory %s is in inode %d\n", path, inode);
    list_dir (inode);   // Minix!
  }
  return;
};

#line 17170 "../diss-hgesser-ulix.tex"
void simplefs_ls () {
  fdc_read_sector (1, 0, (char*)simplefs_fat);
  int i;
  for (i=0; i<32; i++) {
    if (simplefs_fat[i].sector != 0)
    printf ("%-12s %7d %4d\n", 
      simplefs_fat[i].name,
      simplefs_fat[i].size,
      simplefs_fat[i].sector);
  };
  return;
};

int simplefs_get_fd () {
  int i;
  for (i=0; i<32; i++) {
    if (simplefs_openfiles[i].used == 0) {
      // found a free one
      simplefs_openfiles[i].used = 1;
      return i;
    };
  };
  // found no free FD
  return -1;
};

int simplefs_open (char* filename) {
  int i, fd;
  fdc_read_sector (1, 0, (char*)simplefs_fat);
  for (i=0; i<32; i++) {
    if (simplefs_fat[i].sector != 0) {
      if (strcmp(simplefs_fat[i].name, filename)) {
        // printf ("file found\n");
        goto found;
      }
    }
  }
  // not found:
  return -1;
  
  found:
  fd = simplefs_get_fd();
  if (fd == -1) {
    // no free FD
    printf ("open: no free fd\n");
    return -1;
  };
  memcpy (simplefs_openfiles[fd].name, simplefs_fat[i].name, 12);
  simplefs_openfiles[fd].size = simplefs_fat[i].size;
  simplefs_openfiles[fd].sector = simplefs_fat[i].sector;
  simplefs_openfiles[fd].pos = 0;  // init 0
  return fd;
};

int simplefs_close (int fd) {
  // set everything to 0
  // printf ("simplefs_close(%d) called\n", fd);
  memset (&simplefs_openfiles[fd], 0, sizeof(simplefs_openfiles_entry));
  return 0;
}
#line 17243 "../diss-hgesser-ulix.tex"
int simplefs_read (int fd, char* buf, int nbytes) {
  char sector[512];
  
#line 17236 "../diss-hgesser-ulix.tex"
if (simplefs_openfiles[fd].sector == 0) {
  // file not open
  return -EBADF;
};
#line 17246 "../diss-hgesser-ulix.tex"
  int pos = simplefs_openfiles[fd].pos;
  
  if (pos+nbytes > simplefs_openfiles[fd].size) {
    // reaching EOF
    nbytes = simplefs_openfiles[fd].size - pos;
  }
  
  int relpos = pos%512;   // where in the buffer do we start?
  int sec = simplefs_openfiles[fd].sector + pos/512;
  int bufpos = 0;
  int count = 0;
  while (nbytes > 0) {
    fdc_read_sector (1, sec, (char*)sector);
    int b = min(512-relpos,nbytes);
    // next line: casting (char*) so that pointer arithmetic works...
    memcpy (buf+bufpos, ((char*)&sector)+relpos, b);
    
    sec++;  // next sector
    nbytes -= b;
    bufpos += b;
    count += b;
    relpos = 0;
  };
  simplefs_openfiles[fd].pos += count;
  return count;
}

int simplefs_write (int fd, char* buf, int nbytes) {
  char sector[512];
  
#line 17236 "../diss-hgesser-ulix.tex"
if (simplefs_openfiles[fd].sector == 0) {
  // file not open
  return -EBADF;
};
#line 17276 "../diss-hgesser-ulix.tex"
  int pos = simplefs_openfiles[fd].pos;
  
  if (pos+nbytes > simplefs_openfiles[fd].size) {
    // reaching EOF
    nbytes = simplefs_openfiles[fd].size - pos;
  }

  int relpos = pos%512;   // where in the buffer do we start?
  int sec = simplefs_openfiles[fd].sector + pos/512;
  int bufpos = 0;
  int count = 0;
  while (nbytes > 0) {
    // each sector that we modify must first be read...
    fdc_read_sector (1, sec, (char*)sector);
    int b = min(512-relpos,nbytes);
    // next line: casting (char*) so that pointer arithmetic works...
    memcpy (((char*)&sector)+relpos, buf+bufpos, b);
    fdc_write_sector (1, sec, (char*)sector);
    
    sec++;  // next sector
    nbytes -= b;
    bufpos += b;
    count += b;
    relpos = 0;
  };
  simplefs_openfiles[fd].pos += count;
  return count;
}

int simplefs_lseek(int fd, int offset, int whence) {
  
#line 17236 "../diss-hgesser-ulix.tex"
if (simplefs_openfiles[fd].sector == 0) {
  // file not open
  return -EBADF;
};
#line 17307 "../diss-hgesser-ulix.tex"
  if (offset<0) return -1;   // negative offset
  switch (whence) {
    case SEEK_SET: simplefs_openfiles[fd].pos = offset; break;
    case SEEK_CUR: simplefs_openfiles[fd].pos += offset; break;
    case SEEK_END: simplefs_openfiles[fd].pos = 
                   simplefs_openfiles[fd].size+offset; break;
    default:       return -1;  // wrong whence value
  }
  return simplefs_openfiles[fd].pos;
}
#line 17382 "../diss-hgesser-ulix.tex"
int buffer_read (int dev, int blockno, char *block) {
  // don't use the buffer before the scheduler is up
  if (!scheduler_is_active) return -1;  // -1 signals: must be read from disk
  
  LOCK (buffer_lock);
  
  debug_printf ("DEBUG: buffer_read (%d,%d,%x) entered\n", dev, blockno, block);

  // check if buffer cache holds the requested block
  int pos = -1;  // position in the cache
  for (int i=0; i<BUFFER_CACHE_SIZE; i++) {
    if ((buffer_cache[i].dev == dev) && (buffer_cache[i].blockno == blockno)) {
      // found it!
      pos = i;
      debug_printf ("DEBUG: in buffer_read, found entry pos = %d\n", pos);
      break;
    }
  }
  
  if (pos == -1) {
    UNLOCK (buffer_lock);
    return -1;  // not found
  }
    
  // we found it: copy the contents, update the counter
  memcpy (block, buffer_cache[pos].buf, BLOCK_SIZE);
  if ((int)buffer_cache[pos].count < 254)
    buffer_cache[pos].count++;

  UNLOCK (buffer_lock);
  return 0;    // success
}
#line 17420 "../diss-hgesser-ulix.tex"
int buffer_write (int dev, int blockno, char *block) {
  // don't use the buffer before the scheduler is up
  if (!scheduler_is_active) return 0;

  LOCK (buffer_lock);
  
  debug_printf ("DEBUG: buffer_write (%d,%d,%x) entered\n", dev, blockno, block);

  // check if buffer cache already holds the requested block
  int pos = -1;  // position in the cache
  for (int i=0; i<BUFFER_CACHE_SIZE; i++) {
    if ((buffer_cache[i].dev == dev) && (buffer_cache[i].blockno == blockno)) {
      // found it!
      pos = i;
      break;
    }
  }
  
  if (pos == -1) {
    // not found, create it
    
#line 17464 "../diss-hgesser-ulix.tex"
pos = -1;  // new search
for (int i=0; i<BUFFER_CACHE_SIZE; i++) {
  // printf ("searching free one; i = %d, buffer_cache[i].dev = %d\n", i, buffer_cache[i].dev);
  if (buffer_cache[i].dev == -1) {
    // this one is free
    pos = i;
    debug_printf ("DEBUG: in buffer_write, found free entry pos = %d\n", pos);
    break;
  }
}

if (pos == -1) {
  // we found no free entry
  
#line 17496 "../diss-hgesser-ulix.tex"
printf ("DEBUG: buffer_write: need to free an entry\n");
pos = 0;  // new search
int least_used_val = buffer_cache[0].count;

for (int i=0; i<BUFFER_CACHE_SIZE; i++) {
  if (buffer_cache[i].count < least_used_val) {
    // this entry was accessed less often
    least_used_val = buffer_cache[i].count;
    pos = i;  // update candidate
  }
}
#line 17478 "../diss-hgesser-ulix.tex"
}

// memset (0, buffer_cache[pos], sizeof (struct buffer_entry));
buffer_cache[pos].dev = dev;
buffer_cache[pos].blockno = blockno;
buffer_cache[pos].count = 0;
#line 17441 "../diss-hgesser-ulix.tex"
  }
  
  // copy the contents, update the counter
  debug_printf ("DEBUG: in buffer_write, pos = %d, memcpy (%x,%x,%x)\n", pos, buffer_cache[pos].buf, block, BLOCK_SIZE);
  if ((pos>=0) && (pos<BUFFER_CACHE_SIZE)) {
    memcpy (buffer_cache[pos].buf, block, BLOCK_SIZE);
    if ((int)buffer_cache[pos].count < 254)
      buffer_cache[pos].count++;
  } else {
    debug_printf ("ERROR in buffer_write; index pos = %d out of range\n", pos);
  }
  
  UNLOCK (buffer_lock);
  
  return 0;    // success
}
#line 17513 "../diss-hgesser-ulix.tex"
boolean buffer_contains (int dev, int blockno) {
  // don't use the buffer before the scheduler is up
  if (!scheduler_is_active) return false;
  
  debug_printf ("DEBUG: buffer_contains (%d,%d) entered\n", dev, blockno);

  // check if buffer cache holds this block
  int pos = -1;  // position in the cache
  for (int i=0; i<BUFFER_CACHE_SIZE; i++) {
    if ((buffer_cache[i].dev == dev) && (buffer_cache[i].blockno == blockno)) {
      // found it!
      pos = i;
      break;
    }
  }
  
  // return (pos != -1);
  if (pos == -1)
    return false;
  else
    return true;
}
#line 18023 "../diss-hgesser-ulix.tex"
void kill (int pid, int signo) {
  TCB *tcb;
  tcb = &thread_table[pid];
  
  if (!tcb->used) { 
    printf ("ERROR in kill: process %d does not exist\n", pid);
    return;    // process does not exist
  }
  
  switch (signo) {
    case SIGSTOP: 
      tcb->state = TSTATE_STOPPED;
      remove_from_ready_queue (pid);
      if (pid == current_task) {
        asm (".intel_syntax noprefix; \
          mov eax, 66;; \
          int 0x80;; \
          .att_syntax; ");
      }
      break;
    case SIGKILL:  
      tcb->used = false;
      remove_from_ready_queue (pid);
      if (pid == current_task) {
        asm (".intel_syntax noprefix; \
          mov eax, 66;; \
          int 0x80;; \
          .att_syntax; ");
      }
      break;
  };
  
  int blocked = tcb->sig_blocked & (1<<signo);
  if (!blocked && signo>=0 && signo<32) {
    tcb->sig_pending |= (1<<signo);
  }
  return;
}
#line 18158 "../diss-hgesser-ulix.tex"
sighandler_t signal (int sig, sighandler_t func) {
  sighandler_t old_func;
  if (sig>=0 && sig<32 && sig!=SIGKILL && sig!=SIGSTOP) {
    old_func = thread_table[current_task].sighandlers[sig];
    thread_table[current_task].sighandlers[sig] = func;
  } else {
    old_func = SIG_ERR;   // wrong signal number
  }
  return old_func;
}
#line 18272 "../diss-hgesser-ulix.tex"
/* Setup a descriptor in the Global Descriptor Table */
void gdt_set_gate(int num, unsigned long base, unsigned long limit,
                  unsigned char access, unsigned char gran)
{
    /* Setup the descriptor base address */
    gdt[num].base_low = (base & 0xFFFF);
    gdt[num].base_middle = (base >> 16) & 0xFF;
    gdt[num].base_high = (base >> 24) & 0xFF;

    /* Setup the descriptor limits */
    gdt[num].limit_low = (limit & 0xFFFF);
    gdt[num].granularity = ((limit >> 16) & 0x0F);

    /* Finally, set up the granularity and access flags */
    gdt[num].granularity |= (gran & 0xF0);
    gdt[num].access = access;
}

/* Should be called by main. This will setup the special GDT
*  pointer, set up the first 3 entries in our GDT, and then
*  finally call gdt_flush() in our assembler file in order
*  to tell the processor where the new GDT is and update the
*  new segment registers */

void gdt_install()
{
    /* Setup the GDT pointer and limit */
    /* We'll have 6 GDT entries; only three are defined now */
    gp.limit = (sizeof(struct gdt_entry) * 6) - 1;
    gp.base = (int) &gdt;

    /* Our NULL descriptor */
    gdt_set_gate(0, 0, 0, 0, 0);

    /* The second entry is our Code Segment. The base address
    *  is 0, the limit is 4GBytes, it uses 4KByte granularity,
    *  uses 32-bit opcodes, and is a Code Segment descriptor.
    *  Please check the table above in the tutorial in order
    *  to see exactly what each value means */
    gdt_set_gate(1, 0, 0xFFFFFFFF, 0x9A, 0xCF);

    /* The third entry is our Data Segment. It's EXACTLY the
    *  same as our code segment, but the descriptor type in
    *  this entry's access byte says it's a Data Segment */
    gdt_set_gate(2, 0, 0xFFFFFFFF, 0x92, 0xCF);
    
    
#line 9947 "../diss-hgesser-ulix.tex"
gdt_set_gate(3, 0, 0xFFFFFFFF, 0xFA, 0xCF);
gdt_set_gate(4, 0, 0xFFFFFFFF, 0xF2, 0xCF);
write_tss(5, 0x10, 0x0);
#line 18318 "../diss-hgesser-ulix.tex"
                                    /* explained later */
    
    /* Flush out the old GDT and install the new changes! */
    gdt_flush();
    
    
#line 9988 "../diss-hgesser-ulix.tex"
tss_flush();
#line 18323 "../diss-hgesser-ulix.tex"
                   /* explained later */
}
/* bkerndev - Bran's Kernel Development Tutorial
*  By:   Brandon F. (friesenb@gmail.com)
*  Desc: Interrupt Descriptor Table management
*
*  Notes: No warranty expressed or implied. Use at own risk. */
#line 18366 "../diss-hgesser-ulix.tex"
size_t strlen(const char *str)
{
    size_t retval;
    for(retval = 0; *str != '\0'; str++) retval++;
    return retval;
}

int strcmp (const char *str1, const char *str2) {
  int endoftest = false;
  int pos = 0;
  int result;
  while (! endoftest) {
    if ( str1[pos] != str2[pos] ) {
      result = false; 
      endoftest = true;
    };
    if ( (str1[pos] == (char)0) && (str2[pos] == (char)0) ) {
      result = true;
      endoftest = true;
    };
    pos++;
  };
  return result;
}

// This one is broken:
/*
int strncmp (const char *str1, const char *str2, uint n) {
  int endoftest = false;
  int pos = 0;
  int result;
  while (! endoftest) {
    if ( str1[pos] != str2[pos] ) {
      result = false; 
      endoftest = true;
    };
    if ( ((str1[pos] == (char)0) && (str2[pos] == (char)0)) || (pos==n) ) {
      result = true;
      endoftest = true;
    };
    pos++;
  };
  return result;
}
*/

int strncmp (const char *s1, const char *s2, uint n) {
  // source: http://en.wikibooks.org/wiki/C_Programming/Strings
  unsigned char uc1, uc2;
  /* Nothing to compare?  Return zero.  */
  if (n == 0)
    return 0;
  /* Loop, comparing bytes.  */
  while (n-- > 0 && *s1 == *s2) {
    /* If we've run out of bytes or hit a null, return zero
       since we already know *s1 == *s2.  */
    if (n == 0 || *s1 == '\0')
      return 0;
    s1++;
    s2++;
  }
  uc1 = (*(unsigned char *) s1);
  uc2 = (*(unsigned char *) s2);
  return ((uc1 < uc2) ? -1 : (uc1 > uc2));
}


int atoi (char* s) {
  int res = 0;
  while ( ('0' <= *s) && (*s <= '9') ) {
    res = res*10 + (*s-'0');
    s++;
  }
  return res;
};
#line 18887 "../diss-hgesser-ulix.tex"
/* These define our textpointer, our background and foreground
*  colors (attributes), and x and y cursor coordinates */
unsigned short *textmemptr;
int attrib = 0x0F;
int revattrib = 0x1F;
int csr_x = 0; int csr_y = 0;

/* Scrolls the screen */
void scroll(void)
{
  unsigned blank, temp;
  term_buffer* term;
  short int target_vt;
  if (scheduler_is_active) {
    target_vt = thread_table[current_task].terminal;
    term = &vt[target_vt];
  } else {
    target_vt = KERNEL_VT;   // kernel: default write to 0
  }

    /* A blank is defined as a space... we need to give it
    *  backcolor too */
    blank = 0x20 | (attrib << 8);

    /* Row 24 is the end, this means we need to scroll up */
    if (cur_vt == target_vt && csr_y >= 24)
    {
        /* Move the current text chunk that makes up the screen
        *  back in the buffer by a line */
        temp = csr_y - 24 + 1;
        memcpy (textmemptr, textmemptr + temp * 80, (24 - temp) * 80 * 2);

        /* Finally, we set the chunk of memory that occupies
        *  the last line of text to our 'blank' character */
        memsetw (textmemptr + (24 - temp) * 80, blank, 80);
        csr_y = 24 - 1;
    }

    if (scheduler_is_active && term->y >= 24)
    {
        /* Move the current text chunk that makes up the screen
        *  back in the buffer by a line */
        temp = term->y - 24 + 1;
        memcpy ((unsigned short*)term->mem, (unsigned short*)term->mem + temp * 80, (24 - temp) * 80 * 2);

        /* Finally, we set the chunk of memory that occupies
        *  the last line of text to our 'blank' character */
        memsetw ((unsigned short*)term->mem + (24 - temp) * 80, blank, 80);
        term->y = 24 - 1;
    }
}
#line 18945 "../diss-hgesser-ulix.tex"
/* Updates the hardware cursor: the little blinking line
*  on the screen under the last character pressed! */
void move_csr(void)
{
    unsigned temp;

    /* The equation for finding the index in a linear
    *  chunk of memory can be represented by:
    *  Index = [(y * width) + x] */
    temp = csr_y * 80 + csr_x;

    /* This sends a command to indicies 14 and 15 in the
    *  CRT Control Register of the VGA controller. These
    *  are the high and low bytes of the index that show
    *  where the hardware cursor is to be 'blinking'. To
    *  learn more, you should look up some VGA specific
    *  programming documents. A great start to graphics:
    *  http://www.brackeen.com/home/vga */
    outportb(0x3D4, 14);
    outportb(0x3D5, temp >> 8);
    outportb(0x3D4, 15);
    outportb(0x3D5, temp);
}

/* Clears the screen */
void cls()
{
    unsigned blank, blankrev;
    int i;

    /* Again, we need the 'short' that will be used to
    *  represent a space with color */
    blank = 0x20 | (attrib << 8);
    blankrev = 0x20 | (revattrib << 8);

    /* Sets the entire screen to spaces in our current
    *  color */
    for(i = 0; i < 24; i++)
        memsetw (textmemptr + i * 80, blank, 80);

    memsetw (textmemptr + i * 80, blankrev, 80);

    /* Update out virtual cursor, and then move the
    *  hardware cursor */
    csr_x = 0;
    csr_y = 0;
    move_csr();
}


/* Puts a character on the serial console
   code from xv6 operating system, uart.c */
   
void uartputc (int c) {
  int i;
  if(!uart)
    return;
  for(i = 0; i < 128 && !(inportb(COM1+5) & 0x20); i++)
    microdelay(10);
  outportb(COM1+0, c);
}


// mehr zu VGA-Hardware
// http://www.opensource.apple.com/source/xnu/xnu-792.13.8/osfmk/console/i386/text_console.c

/*  not needed...
#define VGA_C_START         0x0a
#define VGA_IDX_REG         0x3d4
#define VGA_IO_REG          0x3d5
#define VGA_CURSOR_CS       0x1F
#define VGA_CURSOR_ON       0x20

static char vga_cursor_start = 0;

static void enable_cursor () {
  vga_cursor_start = inportb(VGA_IO_REG) & VGA_CURSOR_CS;
  outportb(VGA_IDX_REG, VGA_C_START);
  outportb(VGA_IO_REG, vga_cursor_start | VGA_CURSOR_ON);
}
*/


/* Puts a single character on the screen */
void kputch(unsigned char c) {
  // check if we're writing to current terminal
  term_buffer* term;
  short int target_vt;
  if (scheduler_is_active) {
    target_vt = thread_table[current_task].terminal;
    term = &vt[target_vt];
  } else {
    target_vt = KERNEL_VT;   // kernel: default write to 0
  }
    
    unsigned short *where;
    unsigned att = attrib << 8;

    /* Handle a backspace, by moving the cursor back one space */
    if(c == 0x08)
    {
        if (cur_vt == target_vt) {
          if (csr_x != 0) csr_x--;
        }
        if (scheduler_is_active) {
          if (term->x != 0) term->x--;
        }
    }
    /* Handles a tab by incrementing the cursor's x, but only
    *  to a point that will make it divisible by 8 */
    else if(c == 0x09)
    {
        if (cur_vt == target_vt) {
          csr_x = (csr_x + 8) & ~(8 - 1);
        }
        if (scheduler_is_active) {
          term->x = (term->x + 8) & ~(8 - 1);
        }
    }
    /* Handles a 'Carriage Return', which simply brings the
    *  cursor back to the margin */
    else if(c == '\r')
    {
        if (cur_vt == target_vt) {
          csr_x = 0;
        }
        if (scheduler_is_active) {
          term->x = 0;
        }
    }
    /* We handle our newlines the way DOS and the BIOS do: we
    *  treat it as if a 'CR' was also there, so we bring the
    *  cursor to the margin and we increment the 'y' value */
    else if(c == '\n')
    {
        if (cur_vt == target_vt) {
          csr_x = 0;    csr_y++;
        }
        if (scheduler_is_active) {
          term->x = 0;  term->y++;
        }
    }
    /* Any character greater than and including a space, is a
    *  printable character. The equation for finding the index
    *  in a linear chunk of memory can be represented by:
    *  Index = [(y * width) + x] */
    else if(c >= ' ')
    {
        if (cur_vt == target_vt) {
          where = textmemptr + (csr_y * 80 + csr_x);
          *where = c | att;	/* Character AND attributes: color */
          csr_x++;
        }
        if (scheduler_is_active) {
          where = (unsigned short*)term->mem + (term->y * 80 + term->x);
          *where = c | att;
          term->x++;
        }
    }

    /* If the cursor has reached the edge of the screen's width, we
    *  insert a new line in there */
    if(csr_x >= 80)
    {
        if (cur_vt == target_vt) {
          csr_x = 0;    csr_y++;
        }
        if (scheduler_is_active) {
          term->x = 0;  term->y++;
        }
    }

    /* Scroll the screen if needed, and finally move the cursor */
    scroll();
    if (cur_vt == target_vt) {
      move_csr();
    };
    
    
    /* also write on serial console
       code taken from xv6 operating system, console.c
    */
    if (c == 0x100) {  //  backspace
      uartputc('\b'); uartputc(' '); uartputc('\b');
    } else uartputc(c);
    
    
    /* also write on BOCHS terminal */
    bochs_putch (c);
}



inline void putnl () {
  // write newline character on console
  
  // die ist von mir ;)
  kputch ('\n');
}





/* Uses the above routine to output a string... */
void kputs(char *text)
{
    int i;

    for (i = 0; i < strlen(text); i++)
    {
        kputch(text[i]);
    }
}
#line 19172 "../diss-hgesser-ulix.tex"
void _set_statusline (char *text, int offset) {
  int i = 0;
  uint videoaddress = VIDEORAM + 80*24*2+2*offset;  // last line of video
  while ((text[i] != 0) && (i<80)) {
    // POKEPH (videoaddress, text[i]);
    // directly write to videoaddress
    // in the beginning this will be 0xB8000, later: 0xD00B8000
    *((char*)videoaddress) = text[i];
    i++;
    videoaddress+=2;
  }
};

void set_statusline (char *text) {
  _set_statusline (text, 0);
};

void set_statusline_hex (uint i) {
  char buf[19];
  sprintf ((char*)&buf, "0x%08x    ", i);
  set_statusline ((char*)&buf);
};

void bochs_puts(char *text)
// analog to kputs(), this one uses the bochs console.
{
    int i;

    for (i = 0; i < strlen(text); i++)
    {
        bochs_putch(text[i]);
    }
}
#line 19212 "../diss-hgesser-ulix.tex"
/* printint ist von mir (hge), und die ist grotten schlecht ;)) */
void printint (int i) {
  char s[8];
  int rest;
  rest = i / 1000000; i = i % 1000000; s[0] = rest + '0';
  rest = i /  100000; i = i %  100000; s[1] = rest + '0';
  rest = i /   10000; i = i %   10000; s[2] = rest + '0';
  rest = i /    1000; i = i %    1000; s[3] = rest + '0';
  rest = i /     100; i = i %     100; s[4] = rest + '0';
  rest = i /      10; i = i %      10; s[5] = rest + '0';
  rest = i;                            s[6] = rest + '0';
  s[7] = (char)0;
  kputs ((char*)&s);
};
#line 19233 "../diss-hgesser-ulix.tex"
void printbits (uint i) {
  int bit = 31;
  char bits[33];
  bits[32]=0;
  for (; bit>=0; bit--) {
    bits[bit] = (char)(i%2 + (int)('0'));
    i=i/2;
  };
  kputs ((char*)&bits);
};
#line 19250 "../diss-hgesser-ulix.tex"
void printhex (uint i) {
  int digit = 7;
  char digits[11];
  digits[0]='0';
  digits[1]='x';
  char c;
  digits[10]=0;
  for (; digit>=0; digit--) {
    c = i%16;
    if (c < 10) {
      c = c+(int)'0';     // digits 0..9
    } else {
      c = c-10+(int)'A';  // digits A..F
    };
    digits[digit+2] = (char)c;
    i=i/16;
  };
  kputs ((char*)&digits);
};
#line 19277 "../diss-hgesser-ulix.tex"
void bochs_printhex (uint i) {
  int digit = 7;
  char digits[11];
  digits[0]='0';
  digits[1]='x';
  char c;
  digits[10]=0;
  for (; digit>=0; digit--) {
    c = i%16;
    if (c < 10) {
      c = c+(int)'0';     // digits 0..9
    } else {
      c = c-10+(int)'A';  // digits A..F
    };
    digits[digit+2] = (char)c;
    i=i/16;
  };
  bochs_puts ((char*)&digits);
};

void bochs_printint (int i) {
  char s[8];
  int rest;
  rest = i / 1000000; i = i % 1000000; s[0] = rest + '0';
  rest = i /  100000; i = i %  100000; s[1] = rest + '0';
  rest = i /   10000; i = i %   10000; s[2] = rest + '0';
  rest = i /    1000; i = i %    1000; s[3] = rest + '0';
  rest = i /     100; i = i %     100; s[4] = rest + '0';
  rest = i /      10; i = i %      10; s[5] = rest + '0';
  rest = i;                            s[6] = rest + '0';
  s[7] = (char)0;
  bochs_puts ((char*)&s);
};

#line 19318 "../diss-hgesser-ulix.tex"
void printhex_statusline (uint i) {
  int digit = 7;
  char digits[11];
  digits[0]='0';
  digits[1]='x';
  char c;
  digits[10]=0;
  for (; digit>=0; digit--) {
    c = i%16;
    if (c < 10) {
      c = c+(int)'0';     // digits 0..9
    } else {
      c = c-10+(int)'A';  // digits A..F
    };
    digits[digit+2] = (char)c;
    i=i/16;
  };
  set_statusline ((char*)&digits);
};
#line 19344 "../diss-hgesser-ulix.tex"
void printhexbyte (unsigned char i) {
  int digit = 1;
  unsigned char digits[3];
  unsigned char c;
  digits[2]=0;
  for (; digit>=0; digit--) {
    c = i%16;
    if (c < 10) {
      c = c+(int)'0';     // digits 0..9
    } else {
      c = c-10+(int)'A';  // digits A..F
    };
    digits[digit] = (char)c;
    i=i/16;
  };
  kputs ((char*)&digits);
};
#line 19368 "../diss-hgesser-ulix.tex"
void bochs_printhexbyte (unsigned char i) {
  int digit = 1;
  unsigned char digits[3];
  unsigned char c;
  digits[2]=0;
  for (; digit>=0; digit--) {
    c = i%16;
    if (c < 10) {
      c = c+(int)'0';     // digits 0..9
    } else {
      c = c-10+(int)'A';  // digits A..F
    };
    digits[digit] = (char)c;
    i=i/16;
  };
  bochs_puts ((char*)&digits);
};
#line 19392 "../diss-hgesser-ulix.tex"
void printbitsandhex (uint i) {
  printbits (i);
  kputch (' ');
  printhex (i);
  return;
};
#line 19405 "../diss-hgesser-ulix.tex"
void hexdump (uint start, uint end) {
  char z;
  for (uint i=start; i < end; i+=16) {
    printhex (i);  // address
    kputs ("  ");
    // hex values
    for (int j=i; j<i+16; j++) {
      printhexbyte ((unsigned char)PEEK(j)); kputch (' ');
      if (j==i+7) kputch (' ');
    };
    kputch (' ');
    // char values
    for (int j=i; j<i+16; j++) {
      z = PEEK(j);
      if ((z>32)&&(z<127)) {
        kputch (PEEK(j));
      } else {
        kputch ('.');
      };
    };
    
    kputch ('\n');
  };
};
#line 19436 "../diss-hgesser-ulix.tex"
void bochs_hexdump (uint start, uint end) {
  char z;
  for (int i=start; i < end; i+=16) {
    bochs_printhex (i);  // address
    bochs_puts ("  ");
    // hex values
    for (int j=i; j<i+16; j++) {
      bochs_printhexbyte ((unsigned char)PEEK(j)); bochs_putch (' ');
      if (j==i+7) bochs_putch (' ');
    };
    bochs_putch (' ');
    // char values
    for (int j=i; j<i+16; j++) {
      z = PEEK(j);
      if ((z>32)&&(z<127)) {
        bochs_putch (PEEK(j));
      } else {
        bochs_putch ('.');
      };
    };

    bochs_puts ("   ");
    bochs_printhex (i-start);  // offset
        
    bochs_putch ('\n');
  };
};

#line 19468 "../diss-hgesser-ulix.tex"
/* Sets the forecolor and backcolor that we will use */
void settextcolor(unsigned char forecolor, unsigned char backcolor)
{
    /* Top 4 bytes are the background, bottom 4 bytes
    *  are the foreground color */
    attrib = (backcolor << 4) | (forecolor & 0x0F);
}

/* Sets our text-mode VGA pointer, then clears the screen for us */
void init_video(void)
{
    textmemptr = (unsigned short *)VIDEORAM;
    cls();
}
#line 19487 "../diss-hgesser-ulix.tex"
void update_statusline () {
  char status_string[81];
  sprintf ((char*)&status_string, "%s \xb3 Free frames: %d \xb3 Free RAM: 0x%x  ", UNAME, free_frames, free_frames*PAGE_SIZE);

  set_statusline ((char*)&status_string);
};
#line 18709 "../diss-hgesser-ulix.tex"
void microdelay (int us) {
};

// SLIP changes
// static void picsetmask(unsigned short mask) {
void picsetmask(unsigned short mask) {
  irqmask = mask;
  outportb(IO_PIC1+1, mask);
  outportb(IO_PIC2+1, mask >> 8);
};

void uartinit(void) {
  char *p;

  // Turn off the FIFO
  outportb(COM1+2, 0);
 
  // 9600 baud, 8 data bits, 1 stop bit, parity off.
  outportb(COM1+3, 0x80);    // Unlock divisor
  outportb(COM1+0, 115200/9600);
  outportb(COM1+1, 0);
  outportb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
  outportb(COM1+4, 0);
  outportb(COM1+1, 0x01);    // Enable receive interrupts.

  // If status is 0xFF, no serial port.
  if(inportb(COM1+5) == 0xFF)
    return;
  uart = 1;

  // Acknowledge pre-existing interrupt conditions;
  // enable interrupts.
  inportb(COM1+2);
  inportb(COM1+0);
  // picenable(IRQ_COM1);
  picsetmask(irqmask & ~(1<<IRQ_COM1));
  // ioapicenable(IRQ_COM1, 0);

  // Announce that we're here.
  for(p="xv6...\n"; *p; p++)
    uartputc(*p);
}
#line 18772 "../diss-hgesser-ulix.tex"
void uart2putc (int c) {
  int i;
  if(!uart2)
    return;
  for(i = 0; i < 128 && !(inportb(COM2+5) & 0x20); i++)
    microdelay(10);
  outportb(COM2+0, c);
}

void uart2init(void) {
  // Turn off the FIFO
  outportb(COM2+2, 0);
 
  // 9600 baud, 8 data bits, 1 stop bit, parity off.
  outportb(COM2+3, 0x80);    // Unlock divisor
  outportb(COM2+0, 115200/9600);
  outportb(COM2+1, 0);
  outportb(COM2+3, 0x03);    // Lock divisor, 8 data bits.
  outportb(COM2+4, 0);
  outportb(COM2+1, 0x01);    // Enable receive interrupts.

  // If status is 0xFF, no serial port.
  if(inportb(COM2+5) == 0xFF)
    return;
  uart2 = 1;

  // Acknowledge pre-existing interrupt conditions;
  // enable interrupts.
  inportb(COM2+2);
  inportb(COM2+0);
  picsetmask(irqmask & ~(1<<IRQ_COM2));

  // send CMD_STAT
  // uart2putc(1);
}
#line 18823 "../diss-hgesser-ulix.tex"
static int uart2getc (void) { 
  if(!uart2)
    return -1;
  if(!(inportb(COM2+5) & 0x01))
    return -1;
  return inportb(COM2+0);
}

void serial_hard_disk_handler (struct regs *r) {
  
  // ack interrupt
  char c = uart2getc ();

  if (1==0) {
    if ((c>32)&&(c<128)) putch (c);
    else putch ('+');
  }
  serial_hard_disk_buffer[serial_hard_disk_pos++] = c; 
  
  if (serial_hard_disk_pos == 1024) {
    // serial_hard_disk_buffer[1024] = 0;
    // printf ("\nRECEIVED A SECTOR FROM THE SERIAL DISK\n");
    // printf ("BUFFER: >>%s<<\n", serial_hard_disk_buffer);
    serial_hard_disk_pos = 0;
    
    // copy buffer to proper serial hard disk buffer
    memcpy ( &(serial_disk_buffer[serial_disk_buffer_start].sector), 
             &serial_hard_disk_buffer, 1024 );
    serial_disk_reader = 0;  // reading a sector is finished
  }
}
#line 2651 "../diss-hgesser-ulix.tex"
void kgetch (char* c) {
  int t = thread_table[current_task].terminal;
  if (t<0 || t>TERMINALS-1) {
    printf ("ERROR: terminal not set! setting to 0\n");
    t = 0;
  }
  terminal_t *term = &terminals[t];

  *c = 0;
  while (*c == 0) {
    // asm ("hlt");  // let processor sleep until next interrupt
    if (term->kbd_count > 0) {
      // printf (".");
      term->kbd_count--;
      term->kbd_lastread = (term->kbd_lastread+1) % SYSTEM_KBD_BUFLEN;
      *c = term->kbd[term->kbd_lastread];
    } else {
      *c = 0;
    };
  };
  return;
};
#line 2681 "../diss-hgesser-ulix.tex"
void kreadline ( char *s, int maxlength ) {
  DISABLE_SCHEDULER;
  char c;
  int pos=0;
  for (;;) {
    asm ("sti");
    kgetch (&c);   // read one character from the keyboard
    if ((c == 0x08) && (pos>0)) {
      // backspace
      pos--;
      kputch (c); kputch (' '); kputch (c);
    } else if ( c == '\n' ) {
      // newline: end of input
      putch ('\n');
      s[pos] = (char) 0;
      ENABLE_SCHEDULER;
      return;
    } else if ( (c != 0x08) && (pos < maxlength) ) {
      // other character
      kputch(c);
      s[pos++] = c;
    };
  };
};
#line 19518 "../diss-hgesser-ulix.tex"
void command_stat() {
  printf ("MAX_ADDRESS:      %d \n", MAX_ADDRESS);
  printf ("PAGE_SIZE:        %d \n", PAGE_SIZE);
  printf ("NUMBER_OF_FRAMES: %d \n", NUMBER_OF_FRAMES);
};

uint page_desc_2_frame_address (page_desc pd);
page_desc* fill_page_desc (page_desc *pd, uint present,
                           uint writeable, uint user_accessible,
                           uint dirty, uint frame_addr);

#define KMAP(pd,frame) fill_page_desc (pd, true, true, false, false, frame)
#define UMAP(pd,frame) fill_page_desc (pd, true, true, true,  false, frame)

void command_test() {
  kputs ("current_pd as INT:              "); printbitsandhex (*(uint*)(current_pd)); kputs("\n");
  kputs ("current_pd->ptds[0].frame_addr.:"); printbitsandhex (current_pd->ptds[0].frame_addr<<12); kputs("\n");  
  kputs ("current_pt as INT:              "); printbitsandhex (*(uint*)(current_pt)); kputs("\n");
  kputs ("address of current_pd:          "); printhex ((uint)current_pd); kputs("\n");
  kputs ("address of current_pt:          "); printhex ((uint)current_pt); kputs("\n");

  kputs ("size of current_pd:             "); printhex (sizeof(*current_pd)); kputs("\n");
  kputs ("size of current_pt:             "); printhex (sizeof(*current_pt)); kputs("\n");
  
  kputs ("address of frame table:         "); printhex ((uint)ftable); putnl();
  kputs ("hexdump ftable\n");
  hexdump ((uint)&place_for_ftable, ((uint)&place_for_ftable) + 1);
};
  


extern unsigned int stack_first_address, stack_last_address;
void command_mem() {
  kputs ("kernel_pd as INT:               "); printbitsandhex (*(int*)(&kernel_pd)); kputs("\n");
  kputs ("kernel_pd.ptds[0].frame_addr:   "); printbitsandhex (kernel_pd.ptds[0].frame_addr<<12); kputs("\n");  
  kputs ("kernel_pd.ptds[768].frame_addr: "); printbitsandhex (kernel_pd.ptds[768].frame_addr<<12); kputs("\n");  
  kputs ("kernel_pd.ptds[831].frame_addr: "); printbitsandhex (kernel_pd.ptds[831].frame_addr<<12); kputs("\n");  
  kputs ("kernel_pd.ptds[832].frame_addr: "); printbitsandhex (kernel_pd.ptds[832].frame_addr<<12); kputs("\n");  
  kputs ("kernel_pd.ptds[833].frame_addr: "); printbitsandhex (kernel_pd.ptds[833].frame_addr<<12); kputs("\n");  
  kputs ("kernel_pt as INT:               "); printbitsandhex (*(int*)(&kernel_pt)); kputs("\n");
  kputs ("address of kernel_pd:           "); printhex ((uint)&kernel_pd); kputs("\n");
  kputs ("address of kernel_pt:           "); printhex ((uint)&kernel_pt); kputs("\n");
  kputs ("stack_first_address:            "); printhex ((uint)&stack_first_address); kputs("\n");
  kputs ("stack_last_address:             "); printhex ((uint)&stack_last_address); kputs("\n");
  kputs ("free_frames:                    "); printint (free_frames); kputch ('\n');
  
  uint esp;
  __asm__ __volatile__("mov %%esp, %0": "=r"(esp));
  kputs ("ESP:                            "); printhex(esp); kputs ("\n");

  
};

void command_time() {
  short int hour, min, sec;
    hour = (system_time/60/60)%24;
    min = (system_time/60)%60;
    sec = system_time%60;
    printf ("The time is %02d:%02d:%02d.\n", hour, min, sec);
};

void command_uname() {
  printf ("%s; Build: %s \n", UNAME, BUILDDATE);
};

void command_pfault() {
  uint adr = 0x108000;
  printf("Causing a Page fault: accessing address 0x%08x \n", adr);
  uint *pointer = (uint*)(adr);
  uint pagefault = *pointer;
  printbits(pagefault); kputch('\n');
  kputs("adr/4096: "); printhex(adr/4096); putnl();
  adr = pageno_to_frameno (adr/4096);
  kputs("pageno_to_frameno (adr/4096): "); printhex(adr); putnl();
  
}

void command_div0() {
  // Test for exception
  int zero = 0; int i = 10 / zero;
  kputch(i);
}

void command_hexdump() {
  // hexdump (0x00100000,0x00100060); kputch('\n');
  hexdump (0xC0100000,0xC0100060); kputch('\n');
  hexdump (0xD0100000,0xD0100060);
};

void command_check() {
  kputs ("Performing integrity checks\n");
  
  kputs ("Serching for strange pointers in page table\n");
  page_directory* pd;
  // page_table_desc* ptd;
  pd = current_pd;
  // page_table* pt;
  
  kputs ("current_pd: "); printhex ((uint)pd); putnl();
  
  // *ptd = pd->ptds[0];
  // kputs ("frame_addr of 1st c_pd entry: "); printhex (ptd->frame_addr << 12); putnl();
  
  for ( int i=0; i<770; i++) {
    kputs ("address of pd->ptds["); printint (i); kputs("]: "); 
    printhex ((uint)&(pd->ptds[i])); 
    kputs (" --> ");
    printhex (pd->ptds[i].frame_addr << 12);
    putnl();
    if (i==2) i=767;
  }
};

void command_malloc () {
  printf ("Allocating 4 M with kmalloc()\n");
  uint* p;
  p = kmalloc (4*1024*1024);
  printf ("Address of p: %x \n", p);
  printf ("Testing access to p\n");
  for (uint i = 0; i< 1024*1024; i+=1) {
    if (i%4 == 0) set_statusline_hex(i);
    p[i] = 0xAABBCCDD;
    if (p[i] != 0xAABBCCDD) printf ("Error\n");
  };

  printf ("Allocating another 16 K with kmalloc()\n");
  uint* q;
  q = kmalloc (16*1024);
  printf ("Address of q: %x \n", q);

  printf ("Allocating another 16 K with kmalloc()\n");
  uint* r;
  r = kmalloc (16*1024);
  printf ("Address of r: %x \n", q);

  hexdump ((uint)p-16, (uint)(p+12)-16);
  hexdump ((uint)q-16, (uint)(q+12)-16);
  
  printf ("Testing kfree with p, q:\n");
  kfree (p); kfree(q);
  // printf ("Testing kfree with non-malloced data:\n");
  // int j; kfree (&j);
};

void print_process_list () {  
  int i;
  printf (" PID PPID ESP      EIP      EBP      Stack    AS  State Exi Cmdline\n");
  for (i=0;i<MAX_THREADS; i++) {
    if (thread_table[i].used) {
      printf ("%4d %4d %08x %08x %08x %08x %2d  %-5s %3d %s\n",
        thread_table[i].tid,
        thread_table[i].ppid,
        thread_table[i].regs.esp,
        thread_table[i].regs.eip,
        thread_table[i].regs.ebp,
        thread_table[i].kstack,
        thread_table[i].addr_space,
        state_names[thread_table[i].state],
        thread_table[i].exitcode,
        thread_table[i].cmdline);
    }
  }
  return;
}

void command_longhelp () {
  printf ("exit         stop system (actually: relaunch shell...)\n"
          "test\n"
          "pfault, div0 test faults\n"
          "mem          show memory (frames, pages) info\n"
          "stat\n"
          "uname        show Ulix version\n"
          "hexdump      show hexdump of some memory area\n"
          "clear        clear the screen\n"
          "gf, gp, gp1k get a frame, a page, 1000 pages\n"
          "rp           release page\n"
          "bdump\n"
          "check\n"
          "malloc       test kernel malloc\n"
          "time         show time\n"
          "cloneas <n>  clone address space (argument: size)\n"
          "listas\n"
          "testas\n"
          "ps           process list\n"
          "init         start user mode (come back with Shift-Esc)\n"
          "exec         start program from disk (come back with Shift-Esc)\n"
          "testdisk     test Serial Disk Interface\n"
          "enable       (re-)enable scheduler (helpful?)\n"
          "ls           list contents of floppy fdb\n"
  );
          
}
#define SHELL_COMMANDS "help, exit, test, pfault, div0, mem, stat, uname, hexdump, clear, gf, gp, rp, gp1k, bdump, check, malloc, time, cloneas x, listas, testas, init, exec, testdisk, enable, longhelp, ls, ps"

void run_command (char* s) {
  if ( strcmp (s, "mem2") ) {
    command_mem();
  } else if ( strcmp (s, "stat") ) {
    command_stat();
  } else if ( strcmp (s, "uname") ) {
    command_uname();
  } else if ( strcmp (s, "help") ) {
    printf ("Commands: %s \n", SHELL_COMMANDS);
  } else if ( strcmp (s, "test") ) {
    command_test();
  } else if ( strcmp (s, "init") ) {
    printf ("Entering user mode, starting init process\n");
    create_init_process();
  } else if ( strcmp (s, "pfault") ) {
    command_pfault();
  } else if ( strcmp (s, "div0") ) {
    command_div0();
  } else if ( strcmp (s, "hexdump") ) {
    command_hexdump();
  } else if ( strcmp (s, "check") ) {
    command_check();
  } else if ( strcmp (s, "clear") ) {
    cls();
  } else if ( strcmp (s, "usermode") ) {
    run_first_process();
  } else if ( strcmp (s, "mem") ) {
    print_page_table();
  } else if ( strcmp (s, "ps") ) {
    print_process_list();
  } else if ( strcmp (s, "mem2") ) {
    command_mem();
  } else if ( strcmp (s, "malloc") ) {
    command_malloc();
  } else if ( strcmp (s, "longhelp") ) {
    command_longhelp();
  } else if ( strcmp (s, "enable") ) {
    ENABLE_SCHEDULER;
  } else if ( strncmp (s, "cloneas", 7) == 0 ) {
    // clone address space
    int arg;
    arg = atoi (s+8);
    if (arg==0) return; // skip command
    printf ("cloneas %d\n", arg);
    int i = create_new_address_space(arg);
    activate_address_space (i);
    printf ("Address space %d activated\n", i);
   
  } else if ( strcmp (s, "testas") ) {
    int i = create_new_address_space(1);  // create AS #1
    activate_address_space (i);
    i = create_new_address_space(1);  // create AS #2
    activate_address_space (i);
    goto done;
    create_new_address_space(1);  // create AS #3
    goto done;
    uint* testptr = (uint*)(0x0);
    activate_address_space(1); // *testptr = 5;
    printf ("DEBUG: AS #1: 0x0 -> 0x%x\n", mmu(1,0x0));

    activate_address_space(1); *testptr = 10;
    activate_address_space(2); *testptr = 20;
    activate_address_space(3); *testptr = 30;

    activate_address_space(1); printf ("AS #1: *test = %d\n", *testptr);
    activate_address_space(2); printf ("AS #2: *test = %d\n", *testptr);
    activate_address_space(3); printf ("AS #3: *test = %d\n", *testptr);
    activate_address_space(0); 
        
    printf ("AS #0: 0x0 -> 0x%x \n", mmu(0,0x0));
    printf ("AS #1: 0x0 -> 0x%x \n", mmu(1,0x0));
    printf ("AS #2: 0x0 -> 0x%x \n", mmu(2,0x0));
    printf ("AS #3: 0x0 -> 0x%x \n", mmu(3,0x0));
    printf ("Activated \n");
    done: ;
  } else if ( strcmp (s, "listas") ) {
    list_address_spaces();
  } else if ( strcmp (s, "bdump") ) {
    kputs ("Memory Dump to Bochs console - you will see nothing in qemu.\n");
    kputs ("This will take several minutes...\n");
    bochs_puts ("Memory Dump: GDT\n");
    // bochs_hexdump(0xc0000000,0xc03fdfff);
    bochs_hexdump((uint)&gdt,(uint)&gdt+sizeof(gdt));
    bochs_puts ("Memory Dump: current_pd\n");
    bochs_hexdump((uint)current_pd,(uint)current_pd+sizeof(*current_pd));
    bochs_puts ("Memory Dump: current_pt\n");
    bochs_hexdump((uint)current_pt,(uint)current_pt+sizeof(*current_pt));
    
  } else if ( strcmp (s, "gf") ) {
    uint newframeid = request_new_frame();
    kputs ("New frame ID: "); printint (newframeid); kputch ('\n');
  } else if ( strcmp (s, "gp") ) {
    /* uint* page = */ request_new_page(0);
    // kputs (", Page @ "); printhex ((uint)page); kputch ('\n');
  } else if ( strcmp (s, "rp") ) {
    printf ("releasing page range 0xc03fe..0xc07e6 \n");
    // release_page (0xc03fe);
    release_page_range (0xc03fe,0xc07e6);
  } else if ( strcmp (s, "time") ) {
    command_time();
  } else if ( strcmp (s, "gp1k") ) {
    char buf[20];
    uint* page;
    for (int i=0; i<1024; i++) {
      sprintf ((char*)&buf, "Create: %d   ", i);
      set_statusline ((char*)&buf);
      page = request_new_page(0);
      // kputs (", Page @ "); printhex ((uint)page); kputch ('\n');
    }
  } else if ( strcmp (s, "gp10k") ) {
    char buf[20];
    uint* page;
    for (int i=0; i<10*1024; i++) {
      sprintf ((char*)&buf, "Create: %d   ", i);
      set_statusline ((char*)&buf);
      page = request_new_page(0);
      // kputs (", Page @ "); printhex ((uint)page); kputch ('\n');
    }
  } 
    else if ( strcmp (s, "testdisk") ) {

    /*
    char buf_array[1024];
    char *buf;
    buf = &buf_array;
    printf ("address of buf: %x\n", buf);
    kernel_read_sector (1, buf);
    kernel_read_sector (1, buf);
    kernel_read_sector (1, buf);
    */

    show_superblock();
    create_null_file(4000, "test0002.txt");
    list_dir (1);;

    /*
    uart2putc(CMD_STAT);
    // printf ("start: %d, end: %d\n", serial_disk_buffer_start, serial_disk_buffer_end);
    printf ("Going to send a sector.\n");
    char buf[1024];
    memcpy (&buf, "Hallo Test!\0", 13);
    kernel_write_sector (600, (char*)&buf);

    printf ("Going to request two sectors.\n");
    kernel_read_sector (0, (char*)&buf);
    kernel_read_sector (0, (char*)&buf);

    // printf ("start: %d, end: %d\n", serial_disk_buffer_start, serial_disk_buffer_end)
    */
    
  }
    else if ( strcmp (s, "exec") ) {
      start_program_from_disk ("/sh");
      activate_address_space (1);
      ENABLE_SCHEDULER;
      cpu_usermode (0, 64*1024);
  }
    else if ( strcmp (s, "ls") ) {
      simplefs_ls ();
      asm ("sti");
  }  
    
    else if ( strcmp (s, "") ) {
    // no command
    ;
  } else {
    printf ("Error: >%s< not found\n", s);
  }
  return;
}




void simple_shell() {
  char s[101];

  system_kbd_pos = 0;
  system_kbd_lastread = -1;
  system_kbd_count = 0;

  printf ("Ulix Shell. Commands: %s\n", SHELL_COMMANDS);
  printf ("Press [Esc] to display page table.\n");
  printf ("Press [Shift+Esc] to relaunch shell when in user mode.\n");
  printf ("Press [Shift+n] to switch to address space n (0..9).\n");
  for (;;) {
    update_statusline ();
    kputs ("esser@ulix:~$ ");
    kreadline ((char*)&s,sizeof(s)-1);
    if ( strcmp ((char*)&s, "exit") ) return;
    run_command ((char*)&s);
  };
};
#line 1843 "../diss-hgesser-ulix.tex"
int main(void *mboot_ptr, uint initial_stack) {

  
#line 9424 "../diss-hgesser-ulix.tex"
thread_table[0].prev = 0;
thread_table[0].next = 0;
#line 11694 "../diss-hgesser-ulix.tex"
for (int i=0; i < MAX_SEMAPHORES; i++) {
  kl_semaphore_table[i].counter = 0;
  initialize_blocked_queue(&kl_semaphore_table[i].bq);
  kl_semaphore_table[i].used = false;
}

#line 17166 "../diss-hgesser-ulix.tex"
memset (simplefs_openfiles, 0, sizeof(simplefs_openfiles));
#line 1846 "../diss-hgesser-ulix.tex"
  
#line 18756 "../diss-hgesser-ulix.tex"
uartinit ();
printf ("Serial port active\n");
#line 1846 "../diss-hgesser-ulix.tex"
                         // for debugging
  
#line 18810 "../diss-hgesser-ulix.tex"
uart2init ();
printf ("Serial port 2 active\n");
#line 18861 "../diss-hgesser-ulix.tex"
//  irq_install_handler (IRQ_COM2, serial_hard_disk_handler);

// SLIP MOD use own isr routine
irq_install_handler (IRQ_COM1, serial_hard_disk_handler);
extern void slip_isr();
irq_install_handler (IRQ_COM2, slip_isr);
#line 1847 "../diss-hgesser-ulix.tex"
                              // we don't want to deal with IDE/FD stuff
  
#line 5829 "../diss-hgesser-ulix.tex"
// file page directory with null entries
for (int i=1; i<1024; i++) {
  // Note: loop starts with i=1, not i=0
  fill_page_table_desc (&(current_pd->ptds[i]), false, false, false, 0);
};

// make page table kernel_pt first entry of page directory kernel_pd
/*
fill_page_table_desc (
  &(current_pd->ptds[0]), // address of first page directory entry
  true,                   // present
  true,                   // writeable
  true,                   // user_accessible, must be changed later 
  (uint)(current_pt)-0xC0000000      // pointer to the page table
);
*/
KMAPD ( &(current_pd->ptds[0]), (uint)(current_pt)-0xC0000000 );

// make page table kernel_pt also 768th entry of page directory kernel_pd
/*
fill_page_table_desc (
  &(kernel_pd.ptds[768]), // address of 768th page directory entry
  true,                   // present
  true,                   // writeable
  true,                   // user_accessible
  (uint)(current_pt)-0xC0000000      // pointer to the page table
);
*/
KMAPD ( &(kernel_pd.ptds[768]), (uint)(current_pt)-0xC0000000 );

for (int i=0; i<1022; i++) {
  // map 1023 pages (4 MB minus 1 page)
  
#line 5579 "../diss-hgesser-ulix.tex"
/*
fill_page_desc (
  &(current_pt->pds[i]), // address of i-th entry
  true,                  // present: yes
  true,                  // writeable: yes
  true,                  // user accessible: yes
  false,                 // dirty: no
  i*4096                 // physical address: start of i-th frame
);
*/
KMAP ( &(current_pt->pds[i]), i*4096 );
#line 5862 "../diss-hgesser-ulix.tex"
};

// TODO: WHAT'S Going on here? This maps 1022 pages, not 1023...

/*
for (int i=1022; i<1024; i++) {
  fill_page_desc ( &(current_pt->pds[i]), false, false, false, false, 0 );
};
*/

kputs("Kernel page directory setup.\n");
#line 1849 "../diss-hgesser-ulix.tex"
  
#line 5881 "../diss-hgesser-ulix.tex"
uint cr0;
char *kernel_pd_address;
kernel_pd_address = (char*)(current_pd) - 0xC0000000;
__asm__ __volatile__ ("mov %0, %%cr3" :           : "r"(kernel_pd_address)); // write CR3
__asm__ __volatile__ ("mov %%cr0, %0" : "=r"(cr0) :                ); // read  CR0
cr0 |= (1<<31);                       // Enable paging by setting PG bit 31 of CR0
__asm__ __volatile__ ("mov %0, %%cr0" :           : "r"(cr0)       ); // write CR0
#line 7502 "../diss-hgesser-ulix.tex"
for (int id=1; id<MAX_ADDR_SPACES; id++) address_spaces[id].free = true;
// loops from 1 to 1023; 0 is for kernel page directory:

// we also want to initialize address space 0 (for the kernel
// address space), but we need to postpone this until the system
// is further up.
// We will put the following lines in the address space creation
// function to be run when it is called the first time.
// 
address_spaces[0].free = false;
address_spaces[0].pd   = &kernel_pd;
address_spaces[0].physical = 0;
address_spaces[0].pid  = -1;         // not a process
#line 1850 "../diss-hgesser-ulix.tex"
  gdt_install();
  init_video(); cls();
  printf("%s                           Build: %s\n", 
    UNAME, BUILDDATE); 

  
#line 1874 "../diss-hgesser-ulix.tex"
idt_install();
isrs_install();
irq_install();
timer_install();
keyboard_install();

__asm__ __volatile__ ("sti");
#line 2646 "../diss-hgesser-ulix.tex"
keyboard_queue.next = keyboard_queue.prev = 0;
#line 3443 "../diss-hgesser-ulix.tex"
waitpid_queue.next = waitpid_queue.prev = 0;
#line 5905 "../diss-hgesser-ulix.tex"
for (int i=0; i<1024; i++) { 
  // null entries:
  fill_page_desc ( &(video_pt.pds[i]), false,false,false,false,0 );
